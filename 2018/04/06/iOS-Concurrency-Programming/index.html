<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 我所理解的 iOS 并发编程 · Hexo</title><meta name="description" content="我所理解的 iOS 并发编程 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/3290954642" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/boolchow" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">我所理解的 iOS 并发编程</h1><div class="post-info">Apr 6, 2018</div><div class="post-content"><a id="more"></a>
<p>无论在哪个平台，并发编程都是一个让人头疼的问题。庆幸的是，相对于服务端，客户端的并发编程简单了许多。这篇文章主要讲述一些基于 iOS 平台的一些并发编程相关东西，我写博客习惯于先介绍原理，后介绍用法，毕竟对于 API 的使用，官网有更好的文档。</p>
<h3 id="一些原理性的东西"><a href="#一些原理性的东西" class="headerlink" title="一些原理性的东西"></a>一些原理性的东西</h3><p>为了便于理解，这里先解释一些相关概念。如果你对这些概念已经很熟悉，可以直接跳过。</p>
<h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h4><p>从操作系统定义上来说，进程就是系统进行资源分配和调度的基本单位，系统创建一个线程后，会为其分配对应的资源。在 iOS 系统中，进程可以理解为就是一个 App。iOS 并没有提供可以创建进程的 API，即使你调用 <code>fork()</code> 函数，也不能创建新的进程。所以，<strong>本文所说的并发编程，都是针对线程来说的</strong>。</p>
<h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h4><p>线程是程序执行流的最小单元。一般情况下，一个进程会有多个线程，或者至少有一个线程。一个线程有创建、就绪、运行、阻塞和死亡五种状态。线程可以共享进程的资源，所有的问题也是因为共享资源引起的。</p>
<h4 id="3-并发"><a href="#3-并发" class="headerlink" title="3.并发"></a>3.并发</h4><p>操作系统引入线程的概念，是为了使过个 CPU 更好的协调运行，充分发挥他们的并行处理能力。例如在 iOS 系统中，你可以在主线程中进行 UI 操作，然后另启一些线程来处理与 UI 操作无关的事情，两件事情并行处理，速度比较快。这就是并发的大致概念。</p>
<h4 id="4-时间片"><a href="#4-时间片" class="headerlink" title="4.时间片"></a>4.时间片</h4><p>按照 <a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E7%89%87" target="_blank" rel="noopener">wiki</a> 上面解释：是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。线程可以被认为是 ”微进程“，因此这个概念也可以用到线程方面。</p>
<p>一般操作系统使用时间片轮转算法进行调度，即每次调度时，总是选择就绪队列的队首进程，让其在CPU上运行一个系统预先设置好的时间片。一个时间片内没有完成运行的进程，返回到绪队列末尾重新排队，等待下一次调度。不同的操作系统，时间片的范围不一致，一般都是毫秒（ms）级别。</p>
<h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h4><p>死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：</p>
<ul>
<li>互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<p>为了便于理解，这里举一个例子：一座桥，同一时间只允许一辆车经过（<strong>互斥</strong>）。两辆车 A,B 从桥的两端开上桥，走到桥的中间。此时 A 车不肯退（<strong>不可剥夺</strong>），又想占用 B 车所占据的道路；B 车此时也不肯退，又想占用 A 车所占据的道路（<strong>请求和保持</strong>）。此时，A 等待 B 占用的资源，B 等待 A 占用的资源（<strong>环路等待</strong>），两车僵持下去，就形成了<strong>死锁现象</strong>。</p>
<h4 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5.线程安全"></a>5.线程安全</h4><p>当多个线程同时访问一块共享资源（例如数据库），因为时序性问题，会导致数据错乱，这就是<strong>线程不安全</strong>。例如数据库中某个整形字段的 value 为 0，此时两个线程同时对其进行写入操作，线程 A 拿到原值为 0，加一后变为 1；线程 B 并不是在 A 加完后拿的，而是和 A 同时拿的，加完后也是 1，加了两次，理想值应该为 2，但是数据库中最终值却是 1。实际开发场景可能要比这个复杂的多。</p>
<p>所谓的线程安全，可以理解为在多个线程操作（例如读写操作）这部分数据时，不会出现问题。</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>因为线程共享进程资源，在并发情况下，就会出现线程安全问题。为了解决此问题，就出现了锁这个概念。在多线程环境下，当你访问一些共享数据时，拿到访问权限，给数据加锁，在这期间其他线程不可访问，直到你操作完之后进行解锁，其他线程才可以对其进行操作。</p>
<p>iOS 提供了多种锁，ibireme 大神的 <a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">这篇文章</a> 对这些锁进行了性能分析，我这里直接把图 cp 过来了：</p>
<p><img src="/uploads/concurrency-programming/lock_benchmark.png" alt="lock_benchmark"></p>
<p>下面针对这些锁，逐一分析。</p>
<h4 id="1-OSSpinLock"><a href="#1-OSSpinLock" class="headerlink" title="1.OSSpinLock"></a>1.OSSpinLock</h4><p>ibireme 大神的文章也说了，虽然这个锁性能最高，但是已经不安全了，建议不再使用，这里简单说一下。</p>
<p>OSSpinLock 是一种自旋锁，主要提供了加锁（<code>OSSpinLockLock</code>）、尝试枷锁（<code>OSSpinLockTry</code>）和解锁（<code>OSSpinLockUnlock</code>）三个方法。对一块资源进行加锁时，如果尝试加锁失败，不会进入睡眠状态，而是一直进行询问（自旋），占用 CPU资源，不适用于较长时间的任务。在自旋期间，因为占用 CPU 导致低优先级线程拿不到 CUP 资源，无法完成任务并释放锁，从而形成了<strong>优先级反转</strong>。</p>
<p>so，虽然性能很高，但是不要用了。而且 Apple 也已经将这个类比较为 deprecate 了。</p>
<blockquote>
<p>自旋锁 &amp; 互斥锁<br>两者大体类似，区别在于：自旋锁属于 busy-waiting 类型锁，尝试加锁失败，会一直处于询问状态，占用 CPU 资源，效率高；互斥锁属于 sleep-waiting 类型锁，在尝试失败之后，会被阻塞，然后进行上下文切换置于等待队列，因为有上下文切换，效率较低。<br>在 iOS 中 NSLock 属于互斥锁。</p>
</blockquote>
<blockquote>
<p>优先级反转 ：当一个高优先级任务访问共享资源时，该资源已经被一个低优先级任务抢占，阻塞了高优先级任务；同时，该低优先级任务被一个次高优先级的任务所抢先，从而无法及时地释放该临界资源。最终使得任务优先级被倒置，发生阻塞。（引用自 <a href="https://zh.wikipedia.org/wiki/%E4%BC%98%E5%85%88%E8%BD%AC%E7%BD%AE" target="_blank" rel="noopener">wiki</a></p>
</blockquote>
<p>关于自旋锁的原理，bestswifter 的文章 <a href="https://bestswifter.com/ios-lock/" target="_blank" rel="noopener">深入理解 iOS 开发中的锁</a> 这篇文章讲得很好，我这里大部分锁的知识引用于此，建议读一下原文。</p>
<p>自旋锁是加不上就一直尝试，也就是一个循环，直到尝试加上锁，伪代码如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lock = <span class="literal">false</span>; <span class="comment">// 一开始没有锁上，任何线程都可以申请锁  </span></span><br><span class="line"><span class="keyword">do</span> &#123;  </span><br><span class="line">    <span class="keyword">while</span>(test_and_set(&amp;lock); <span class="comment">// test_and_set 是一个原子操作,尝试加锁</span></span><br><span class="line">        Critical section  <span class="comment">// 临界区</span></span><br><span class="line">    lock = <span class="literal">false</span>; <span class="comment">// 相当于释放锁，这样别的线程可以进入临界区</span></span><br><span class="line">        Reminder section <span class="comment">// 不需要锁保护的代码        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 ：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OSSpinLock spinLock = OS_SPINLOCK_INIT;</span><br><span class="line">OSSpinLockLock(&amp;spinLock);</span><br><span class="line"><span class="comment">// 被锁住的资源</span></span><br><span class="line">OSSpinLockUnlock(&amp;spinLock);</span><br></pre></td></tr></table></figure>
<h4 id="2-dispatch-semaphore"><a href="#2-dispatch-semaphore" class="headerlink" title="2.dispatch_semaphore"></a>2.dispatch_semaphore</h4><p>dispatch_semaphore 并不属于锁，而是信号量。两者的区别如下：</p>
<ul>
<li>锁是用于线程互斥操作，一个线程锁住了某个资源，其他线程都无法访问，直到整个线程解锁；信号量用于线程同步，一个线程完成了某个动作通过信号量告诉别的线程，别的线程再进行操作。</li>
<li>锁的作用域是线程之间；信号量的作用域是线程和进程之间。</li>
<li>信号量有时候可以充当锁的作用，初次之前还有其他作用。</li>
<li>如果转化为数值，锁可以认为只有 0 和 1；信号量可以大于零和小于零，有多个值。</li>
</ul>
<p>dispatch_semaphore 使用分为三步：create、wait 和 signal。如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread A</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="comment">// execute task A</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task A"</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread B</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="comment">// execute task B</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task B"</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-03</span> <span class="number">21</span>:<span class="number">40</span>:<span class="number">09.068586</span>+<span class="number">0800</span> ConcurrencyTest[<span class="number">44084</span>:<span class="number">1384262</span>] task A</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-03</span> <span class="number">21</span>:<span class="number">40</span>:<span class="number">19.072951</span>+<span class="number">0800</span> ConcurrencyTest[<span class="number">44084</span>:<span class="number">1384265</span>] task B</span><br></pre></td></tr></table></figure>
<p>thread A，B 是两个异步线程，一般情况下，各自执行自己的事件，互不干涉。但是根据 console 输出，B 是在 A 执行完了 10s 执行之后才执行的，显然受到阻塞。使用 dispatch_semaphore 大致执行过程这样：创建 semaphore 时，信号量值为 1；执行到线程 A 的 <code>dispatch_semaphore_wait</code> 时，信号量值减 1，变为 0；然后执行任务 A，执行完毕后 <code>sleep</code> 方法阻塞当前线程 10s；与此同时，线程 B 执行到了 <code>dispatch_semaphore_wait</code>，由于信号量此时为 0，且线程 A 中设置的为 <code>DISPATCH_TIME_FOREVER</code>，因此需要等到线程 A sleep 10s 之后，执行 <code>dispatch_semaphore_signal</code> 将信号量置为 1，线程 B 的任务才开始执行。</p>
<p>根据上面的描述，dispatch_semaphore 的原理大致也就了解了。<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">GCD 源码</a> 对这些方法定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span></span><br><span class="line">dispatch_semaphore_wait(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> value = dispatch_atomic_dec2o(dsema, dsema_value);</span><br><span class="line">	dispatch_atomic_acquire_barrier();</span><br><span class="line">	<span class="keyword">if</span> (fastpath(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">_dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">		<span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> orig;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="comment">// Mach semaphores appear to sometimes spuriously wake up. Therefore,</span></span><br><span class="line">	<span class="comment">// we keep a parallel count of the number of times a Mach semaphore is</span></span><br><span class="line">	<span class="comment">// signaled (6880961).</span></span><br><span class="line">	<span class="keyword">while</span> ((orig = dsema-&gt;dsema_sent_ksignals)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig,</span><br><span class="line">				orig - <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> _<span class="title">timeout</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">			_timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">			_timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">			ret = slowpath(sem_timedwait(&amp;dsema-&gt;dsema_sem, &amp;_timeout));</span><br><span class="line">		&#125; <span class="keyword">while</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno != ETIMEDOUT) &#123;</span><br><span class="line">			DISPATCH_SEMAPHORE_VERIFY_RET(ret);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Fall through and try to undo what the fast path did to</span></span><br><span class="line">		<span class="comment">// dsema-&gt;dsema_value</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">		<span class="keyword">while</span> ((orig = dsema-&gt;dsema_value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dispatch_atomic_cmpxchg2o(dsema, dsema_value, orig, orig + <span class="number">1</span>)) &#123;</span><br><span class="line">				errno = ETIMEDOUT;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Another thread called semaphore_signal().</span></span><br><span class="line">		<span class="comment">// Fall through and drain the wakeup.</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			ret = sem_wait(&amp;dsema-&gt;dsema_sem);</span><br><span class="line">		&#125; <span class="keyword">while</span> (ret != <span class="number">0</span>);</span><br><span class="line">		DISPATCH_SEMAPHORE_VERIFY_RET(ret);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上时对 wait 方法的定义，如果你不想看代码，可以直接听我说：</p>
<ul>
<li>调用 <code>dispatch_semaphore_wait</code> 方法时，如果信号量大于 0，直接返回；否则进入后续步骤。</li>
<li><code>_dispatch_semaphore_wait_slow</code> 方法根据传入 <code>timeout</code> 参数不同，使用 switch-case 处理。</li>
<li>如果传入的是 DISPATCH_TIME_NOW 参数，将信号量加 1 并立即返回。</li>
<li>如果传入的是一个超时时间，调用系统的 <code>semaphore_timedwait</code> 方法进行等待，直至超时。</li>
<li>如果传入的是 DISPATCH_TIME_FOREVER 参数，调用系统的 <code>semaphore_wait</code> 进行等待，直到收到 <code>singal</code> 信号。</li>
</ul>
<p>至于 <code>dispatch_semaphore_signal</code> 就比较简单了，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span></span><br><span class="line">dispatch_semaphore_signal(<span class="keyword">dispatch_semaphore_t</span> dsema)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_atomic_release_barrier();</span><br><span class="line">	<span class="keyword">long</span> value = dispatch_atomic_inc2o(dsema, dsema_value);</span><br><span class="line">	<span class="keyword">if</span> (fastpath(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (slowpath(value == LONG_MIN)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="string">"Unbalanced call to dispatch_semaphore_signal()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>现将信号量加 1，大于 0 直接返回。</li>
<li>小于 0 返回 <code>_dispatch_semaphore_signal_slow</code>，这个方法的作用是调用内核的 semaphore_signal 函数唤醒信号量，然后返回 1。</li>
</ul>
<h4 id="3-pthread-mutex"><a href="#3-pthread-mutex" class="headerlink" title="3.pthread_mutex"></a>3.pthread_mutex</h4><p>Pthreads 是 POSIX Threads 的缩写。<code>pthread_mutex</code> 属于互斥锁，即尝试加锁失败后悔阻塞线程并睡眠，会进行上下文切换。锁的类型主要有三种：<code>PTHREAD_MUTEX_NORMAL</code>、<code>PTHREAD_MUTEX_ERRORCHECK</code>、<code>PTHREAD_MUTEX_RECURSIVE</code>。</p>
<ul>
<li>PTHREAD_MUTEX_NORMAL，普通锁，当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。</li>
<li>PTHREAD_MUTEX_ERRORCHECK，检错锁，如果同一个线程请求同一个锁，则返回 EDEADLK。否则和 PTHREAD_MUTEX_NORMAL 相同。</li>
<li>PTHREAD_MUTEX_RECURSIVE，递归锁，允许一个线程进行递归申请锁。</li>
</ul>
<p>使用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;   <span class="comment">// 定义锁</span></span><br><span class="line"><span class="keyword">pthread_mutexattr_t</span> attr; <span class="comment">// 定义 mutexattr_t 变量</span></span><br><span class="line">pthread_mutexattr_init(&amp;attr); <span class="comment">// 初始化attr为默认属性</span></span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);  <span class="comment">// 设置锁的属性</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr); <span class="comment">// 创建锁</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex); <span class="comment">// 申请锁</span></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex); <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>
<h4 id="4-NSLock"><a href="#4-NSLock" class="headerlink" title="4.NSLock"></a>4.NSLock</h4><p>NSLock 属于互斥锁，是 Objective-C 封装的一个对象。虽然我们不知道 Objective-C 是如何实现的，但是我们可以在 <a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSLock.swift" target="_blank" rel="noopener">swift 源码</a> 中找到他的实现 ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> mutex = _PthreadMutexPointer.allocate(capacity: <span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pthread_mutex_lock(mutex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">   pthread_mutex_unlock(mutex)</span><br><span class="line">#<span class="keyword">if</span> os(macOS) || os(iOS)</span><br><span class="line">  <span class="comment">// Wakeup any threads waiting in lock(before:)</span></span><br><span class="line">   pthread_mutex_lock(timeoutMutex)</span><br><span class="line">   pthread_cond_broadcast(timeoutCond)</span><br><span class="line">   pthread_mutex_unlock(timeoutMutex)</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出他只是将 <code>pthread_mutex</code> 封装了一下。只因为比 <code>pthread_mutex</code> 慢一些，难道是因为方法层级之间的调用，多了几次压栈操作？？？</p>
<p>常规使用：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *mutexLock = [<span class="built_in">NSLock</span> new];</span><br><span class="line">[mutexLock lock];</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">[muteLock unlock];</span><br></pre></td></tr></table></figure>
<h4 id="4-NSCondition-amp-NSConditionLock"><a href="#4-NSCondition-amp-NSConditionLock" class="headerlink" title="4.NSCondition &amp; NSConditionLock"></a>4.NSCondition &amp; NSConditionLock</h4><p>NSCondition 可以同时起到 lock 和条件变量的作用。同样你可以在 <a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSLock.swift" target="_blank" rel="noopener">swift 源码</a> 中找到他的实现 ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">NSCondition</span>: <span class="title">NSObject</span>, <span class="title">NSLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> mutex = _PthreadMutexPointer.allocate(capacity: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> cond = _PthreadCondPointer.allocate(capacity: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        pthread_mutex_init(mutex, <span class="literal">nil</span>)</span><br><span class="line">        pthread_cond_init(cond, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        pthread_mutex_destroy(mutex)</span><br><span class="line">        pthread_cond_destroy(cond)</span><br><span class="line">        mutex.deinitialize(<span class="built_in">count</span>: <span class="number">1</span>)</span><br><span class="line">        cond.deinitialize(<span class="built_in">count</span>: <span class="number">1</span>)</span><br><span class="line">        mutex.deallocate()</span><br><span class="line">        cond.deallocate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pthread_mutex_lock(mutex)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pthread_mutex_unlock(mutex)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pthread_cond_wait(cond, mutex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(until limit: Date)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> timeout = timeSpecFrom(date: limit) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_timedwait(cond, mutex, &amp;timeout) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pthread_cond_signal(cond)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pthread_cond_broadcast(cond)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，它还是遵循 NSLocking 协议，lock 方法同样还是使用的 <code>pthread_mutex</code>，wait 和 signal 使用的是 <code>pthread_cond_wait</code> 和 <code>pthread_cond_signal</code>。</p>
<p>使用 NSCondition 是，先对要操作的临界区加锁，然后因为条件不满足，使用 wait 方法阻塞线程；待条件满足之后，使用 signal 方法进行通知。下面是一个 生产者-消费者的例子：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSCondition</span> *condition = [<span class="built_in">NSCondition</span> new];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *products = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="comment">// consume</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [condition lock];</span><br><span class="line">    <span class="keyword">while</span> (products.count == <span class="number">0</span>) &#123;</span><br><span class="line">        [condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [products removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// product</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [condition lock];</span><br><span class="line">    [products addObject:[<span class="built_in">NSObject</span> new]];</span><br><span class="line">    [condition signal];</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>NSConditionLock 是通过使用 NSCondition 来实现的，遵循 NSLocking 协议，然后这是 <a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSLock.swift" target="_blank" rel="noopener">swift 源码</a> (源码比较占篇幅，我这里简化一下)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">NSConditionLock</span> : <span class="title">NSObject</span>, <span class="title">NSLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _cond = <span class="type">NSCondition</span>()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">(whenCondition condition: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="number">_</span> = lock(whenCondition: condition, before: <span class="type">Date</span>.distantFuture)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> `<span class="title">try</span>`<span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lock(before: <span class="type">Date</span>.distantPast)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">tryLock</span><span class="params">(whenCondition condition: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lock(whenCondition: condition, before: <span class="type">Date</span>.distantPast)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">(withCondition condition: Int)</span></span> &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        _thread = <span class="literal">nil</span></span><br><span class="line">        _value = condition</span><br><span class="line">        _cond.broadcast()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">(before limit: Date)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        <span class="keyword">while</span> _thread != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !_cond.wait(until: limit) &#123;</span><br><span class="line">                _cond.unlock()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _thread = pthread_self()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">(whenCondition condition: Int, before limit: Date)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        <span class="keyword">while</span> _thread != <span class="literal">nil</span> || _value != condition &#123;</span><br><span class="line">            <span class="keyword">if</span> !_cond.wait(until: limit) &#123;</span><br><span class="line">                _cond.unlock()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _thread = pthread_self()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出它使用了一个 NSCondition 全局变量来实现 lock 和 unlock 方法，都是一些简单的代码逻辑，就不详细说了。</p>
<p>使用 NSConditionLock 注意：</p>
<ul>
<li>初始化 NSConditionLock 会设置一个 condition，只有满足这个 condition 才能加锁。</li>
<li><code>-[unlockWithCondition:]</code> <strong>并不是满足条件时解锁，而是解锁后，修改 condition 值</strong>。</li>
</ul>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">CTLockCondition</span>) &#123;</span><br><span class="line">    <span class="built_in">CTLockConditionNone</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">CTLockConditionPlay</span>,</span><br><span class="line">    <span class="built_in">CTLockConditionShow</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testConditionLock &#123;</span><br><span class="line">    <span class="built_in">NSConditionLock</span> *conditionLock = [[<span class="built_in">NSConditionLock</span> alloc] initWithCondition:<span class="built_in">CTLockConditionPlay</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// thread one</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [conditionLock lockWhenCondition:<span class="built_in">CTLockConditionNone</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"thread one"</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        [conditionLock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// thread two</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ([conditionLock tryLockWhenCondition:<span class="built_in">CTLockConditionPlay</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"thread two"</span>);</span><br><span class="line">            [conditionLock unlockWithCondition:<span class="built_in">CTLockConditionShow</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"thread two unlocked"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"thread two try lock failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// thread three</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ([conditionLock tryLockWhenCondition:<span class="built_in">CTLockConditionPlay</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"thread three"</span>);</span><br><span class="line">            [conditionLock unlock];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"thread three locked success"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"thread three try lock failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread four</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> ([conditionLock tryLockWhenCondition:<span class="built_in">CTLockConditionShow</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"thread four"</span>);</span><br><span class="line">            [conditionLock unlock];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"thread four unlocked success"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"thread four try lock failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看输出结果 ：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-05</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">33.801855</span>+<span class="number">0800</span> ConcurrencyTest[<span class="number">97128</span>:<span class="number">3100768</span>] thread two</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-05</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">33.802312</span>+<span class="number">0800</span> ConcurrencyTest[<span class="number">97128</span>:<span class="number">3100768</span>] thread two unlocked</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-05</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">34.804384</span>+<span class="number">0800</span> ConcurrencyTest[<span class="number">97128</span>:<span class="number">3100776</span>] thread three try lock failed</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-05</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">35.806634</span>+<span class="number">0800</span> ConcurrencyTest[<span class="number">97128</span>:<span class="number">3100778</span>] thread four</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-05</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">35.806883</span>+<span class="number">0800</span> ConcurrencyTest[<span class="number">97128</span>:<span class="number">3100778</span>] thread four unlocked success</span><br></pre></td></tr></table></figure>
<p>可以看出，thread one 因为条件和初始化不符，加锁失败，未输出 log; thread two 条件相符，解锁成功，并修改加锁条件；thread three 使用原来的加锁条件，显然无法加锁，尝试加锁失败; thread four 使用修改后的条件，加锁成功。</p>
<h4 id="5-NSRecursiveLock"><a href="#5-NSRecursiveLock" class="headerlink" title="5. NSRecursiveLock"></a>5. NSRecursiveLock</h4><p>NSRecursiveLock 属于递归锁。然后这是 <a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSLock.swift" target="_blank" rel="noopener">swift 源码</a>，只贴一下关键部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">open class NSRecursiveLock: NSObject, NSLocking &#123;</span><br><span class="line">    ...</span><br><span class="line">    public override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">#if CYGWIN</span><br><span class="line">        var attrib : pthread_mutexattr_t? = nil</span><br><span class="line">#else</span><br><span class="line">        var attrib = pthread_mutexattr_t()</span><br><span class="line">#endif</span><br><span class="line">        withUnsafeMutablePointer(to: &amp;attrib) &#123; attrs in</span><br><span class="line">            pthread_mutexattr_settype(attrs, Int32(PTHREAD_MUTEX_RECURSIVE))</span><br><span class="line">            pthread_mutex_init(mutex, attrs)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是使用 <code>PTHREAD_MUTEX_RECURSIVE</code> 类型的 <code>pthread_mutex_t</code> 初始化的。递归所可以在一个线程中重复调用，然后底层会记录加锁和解锁次数，当二者次数相同时，才能正确解锁，释放这块临界区。</p>
<p>使用例子：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testRecursiveLock &#123;</span><br><span class="line">    <span class="built_in">NSRecursiveLock</span> *recursiveLock = [<span class="built_in">NSRecursiveLock</span> new];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (^__block fibBlock)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        [recursiveLock lock];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            [recursiveLock unlock];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span> || num == <span class="number">2</span>) &#123;</span><br><span class="line">            [recursiveLock unlock];</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newValue = fibBlock(num - <span class="number">1</span>) + fibBlock(num - <span class="number">2</span>);</span><br><span class="line">        [recursiveLock unlock];</span><br><span class="line">        <span class="keyword">return</span> newValue;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> value = fibBlock(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value is %d"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-synchronized"><a href="#6-synchronized" class="headerlink" title="6. @synchronized"></a>6. @synchronized</h4><p>@synchronized 是牺牲性能来换取语法上的简洁。如果你想深入了解，建议你去读 <a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">这篇文章</a>。这里说一下他的大概原理：</p>
<p>@synchronized 的加锁过程，大概是这个样子：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">    objc_sync_enter(obj); <span class="comment">// lock</span></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">@finally</span> &#123;</span><br><span class="line">    objc_sync_exit(obj);    <span class="comment">// unlock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@synchronized 的存储结构，是使用哈希表来实现的。当你传入一个对象后，会为这个对象分配一个锁。锁和对象打包成一个对象，然后和一个锁在进行二次打包成一个对象，可以理解为 value；通过一个算法，根据对象的地址得到一个值，作为 key。然后以 key-value 的形式写入哈希表。结构大概是这个样子：</p>
<p><img src="/uploads/concurrency-programming/synchronized结构.png" alt="synchronized结构"></p>
<blockquote>
<p>存储的时候，是以哈希表结构存储，不是我上面画的顺序存储，上面只是一个节点而已。</p>
</blockquote>
<p>@synchronized 的使用就很简单了 ：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *elementArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">@synchronized</span>(elementArray) &#123;</span><br><span class="line">   [elementArray addObject:[<span class="built_in">NSObject</span> new]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h3><p>前面也说了，pthreads 是 POSIX Threads 的缩写。这个东西一般我们用不到，这里简单介绍一下。Pthreads 是POSIX的线程标准，定义了创建和操纵线程的一套API。实现POSIX 线程标准的库常被称作Pthreads，一般用于Unix-like POSIX 系统，如Linux、 Solaris。</p>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p><code>NSThread</code> 是对内核 mach kernel 中的 mach thread 的封装，一个 <code>NSThread</code> 对象就是一个线程。使用频率比较低，除了 API 的使用，没什么可讲的。如果你已经熟悉这些 API，可以跳过这一节了。</p>
<h4 id="1-初始化线程执行一个-task"><a href="#1-初始化线程执行一个-task" class="headerlink" title="1.初始化线程执行一个 task"></a>1.初始化线程执行一个 task</h4><p>使用初始化方法初始化一个 <code>NSTherad</code> 对象，调用 <code>-[cancel]</code>、<code>-[start</code>、<code>-[main]</code> 方法对线程进行操作，一般线程执行完即销毁，或者因为某种异常退出。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 使用 target 对象的中的方法作为执行主体，可以通过 argument 传递一些参数。</span></span><br><span class="line"><span class="comment">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/** 使用 block 对象作为执行主体 */</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 类方法，上面对象方法需要调用 -[start] 方法启动线程，下面两个方法不需要手动启动 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)detachNewThreadWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line">+ (<span class="keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument;</span><br></pre></td></tr></table></figure>
<h4 id="2-在主线程执行一个-task"><a href="#2-在主线程执行一个-task" class="headerlink" title="2.在主线程执行一个 task"></a>2.在主线程执行一个 task</h4><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 说一下最后一个参数，这里你至少指定一个 mode 执行 selector，如果你传 nil 或者空数组，selector 不会执行，虽然方法定义写了 nullable */</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br></pre></td></tr></table></figure>
<h4 id="3-在其他线程执行一个-task"><a href="#3-在其他线程执行一个-task" class="headerlink" title="3.在其他线程执行一个 task"></a>3.在其他线程执行一个 task</h4><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** modes 参数同上一个 */</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait</span><br></pre></td></tr></table></figure>
<h4 id="4-在后台线程执行一个-task"><a href="#4-在后台线程执行一个-task" class="headerlink" title="4.在后台线程执行一个 task"></a>4.在后台线程执行一个 task</h4><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg;</span><br></pre></td></tr></table></figure>
<h4 id="5-获取当前线程"><a href="#5-获取当前线程" class="headerlink" title="5.获取当前线程"></a>5.获取当前线程</h4><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *currentThread;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用线程相关方法时，记得设置好 name，方便后面调试。同时也设置好优先级等其他参数。</p>
</blockquote>
<blockquote>
<p>performSelector: 系列方法已经不太安全，慎用。</p>
</blockquote>
<h3 id="Grand-Central-Dispatch-GCD"><a href="#Grand-Central-Dispatch-GCD" class="headerlink" title="Grand Central Dispatch (GCD)"></a>Grand Central Dispatch (GCD)</h3><p>GCD 是基于 C 实现的一套 API，而且是开源的，如果有兴趣，可以在 <a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">这里</a> down 一份源码研究一下。GCD 是由系统帮我们处理多线程调度，很是方便，也是使用频率最高的。这一章节主要讲解一下 GCD 的原理和使用。</p>
<p>在讲解之前，我们先有个概览，看一下 GCD 为我们提供了那些东西：</p>
<p><img src="/uploads/concurrency-programming/GCD总体结构.png" alt="GCD总体结构"></p>
<p>系统所提供的 API，完全可以满足我们日常开发需求了。下面就根据这些模块分别讲解一下。</p>
<h4 id="1-Dispatch-Queue"><a href="#1-Dispatch-Queue" class="headerlink" title="1. Dispatch Queue"></a>1. Dispatch Queue</h4><p>GCD 为我们提供了两类队列，<strong>串行队列</strong> 和 <strong>并行队列</strong>。两者的区别是：</p>
<ul>
<li>串行队列中，按照 FIFO 的顺序执行任务，前面一个任务执行完，后面一个才开始执行。</li>
<li>并行队列中，也是按照 FIFO 的顺序执行任务，只要前一个被拿去执行，继而后面一个就开始执行，后面的任务无需等到前面的任务执行完再开始执行。</li>
</ul>
<p>除此之外，还要解释一个容易混淆的概念，<strong>并发</strong>和<strong>并行</strong>：</p>
<ul>
<li>并发：是指单独部分可以同时执行，但是需要系统决定怎样发生。</li>
<li>并行：两个任务互不干扰，同时执行。单核设备，系统需要通过切换上下文来实现并发；多核设备，系统可以通过并行来执行并发任务。</li>
</ul>
<p>最后，还有一个概念，<strong>同步</strong>和<strong>异步</strong>：</p>
<ul>
<li>同步 ： 同步执行的任务会阻塞当前线程。</li>
<li>异步 ： 异步执行的任务不会阻塞当前线程。是否开启新的线程，由系统管理。如果当前有空闲的线程，使用当前线程执行这个异步任务；如果没有空闲的线程，而且线程数量没有达到系统最大，则开启新的线程；如果线程数量已经达到系统最大，则需要等待其他线程中任务执行完毕。</li>
</ul>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>我们使用时，一般使用这几个队列：</p>
<ul>
<li><p>主队列 - dispatch_get_main_queue ：一个特殊的串行队列。在 GCD 中，方法主队列中的任务都是在主线程执行。当我们更新 UI 时想 dispatch 到主线程，可以使用这个队列。</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    	<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), 	^&#123;</span><br><span class="line">  	      <span class="comment">// UI 相关操作</span></span><br><span class="line"> 	   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>全局并行队列 - dispatch_get_global_queue ： 系统提供的一个全局并行队列，我们可以通过指定参数，来获取不同优先级的队列。系统提供了四个优先级，所以也可以认为系统为我们提供了四个并行队列，分别为 ：</p>
<ul>
<li>DISPATCH_QUEUE_PRIORITY_HIGH</li>
<li>DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
<li>DISPATCH_QUEUE_PRIORITY_LOW</li>
<li><p>DISPATCH_QUEUE_PRIORITY_BACKGROUND</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span><br><span class="line">   <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">       <span class="comment">// 相关操作</span></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>自定义队列 ：你可以自己定义串行或者并行队列，来执行一些相关的任务，平时开发中也建议用自定义队列。创建自定义队列时，需要两个参数。一个是队列的名字，方便我们再调试时查找队列使用，命名方式采用的是<strong>反向 DNS 命名规则</strong>；一个是队列类型，传 NULL 或者 DISPATCH_QUEUE_SERIAL 代表串行队列，传 DISPATCH_QUEUE_CONCURRENT 代表并行队列，通常情况下，不要传 NULL，会降低可读性。<br>  DISPATCH_QUEUE_SERIAL_INACTIVE 代表串行不活跃队列，DISPATCH_QUEUE_CONCURRENT_INACTIVE 代表并行不活跃队列，在执行 block 任务时，需要被激活。</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.dispatch"</span>,DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>你可以使用 <code>dispatch_queue_set_specific</code>、<code>dispatch_queue_get_specific</code> 和 <code>dispatch_get_specific</code> 方法，为 queue 设置关联的 key 或者根据 key 找到关联对象等操作。</li>
</ul>
<p>可以说，系统为我们提供了 5 中不同的队列，运行在主线程中的 main queue;3 个不同优先级的 global queue; 一个优先级更低的 background queue。除此之外，开发者可以自定义一些串行和并行队列，这些自定义队列中被调度的所有 block 最终都会被放到系统全局队列和线程池中，后面会讲这部分原理。盗用一张经典图：</p>
<p><img src="/uploads/concurrency-programming/gcd-queues.png" alt="gcd-queues"></p>
<h5 id="同步-VS-异步"><a href="#同步-VS-异步" class="headerlink" title="同步 VS 异步"></a>同步 VS 异步</h5><p>我们大多数情况下，都是使用 <code>dispatch_asyn()</code> 做异步操作，因为程序本来就是顺序执行，很少用到同步操作。有时候我们会把 <code>dispatch_syn()</code> 当做锁来用，以达到保护的作用。</p>
<p>系统维护的是一个队列，根据 FIFO 的规则，将 dispatch 到队列中的任务一一执行。有时候我们想把一些任务延后执行以下，例如 App 启动时，我想让主线程中一个耗时的工作放在后，可以尝试用一下 <code>dispatch_asyn()</code>，相当于把任务重新追加到了队尾。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 想要延后的任务</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>通常情况下，我们使用 <code>dispatch_asyn()</code> 是不会造成死锁的。死锁一般出现在使用 <code>dispatch_syn()</code> 的时候。例如：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"dead lock"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>想上面这样写，启动就会报错误。以下情况也如此：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.dispatch"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"dispatch asyn"</span>);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"dispatch asyn -&gt; dispatch syn"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>dispatch_asyn()</code> 整个 block（称作 blcok_asyn） 当做一个任务追加到串行队列队尾，然后开始执行。在 block_asyn 内部中，又进行了 <code>dispatch_syn()</code>，想想要执行 block_syn。因为是串行队列，需要前一个执行完（block_asyn），再执行后面一个（block_syn）；但是要执行完 block_asyn，需要执行内部的 block_syn。互相等待，形成死锁。</p>
<p>现实开发中，还有更复杂的死锁场景。不过现在编译器很友好，我们能在编译执行时就检测到了。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>针对下面这几行代码，我们分析一下它的底层过程：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.dispatch"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"dispatch asyn test"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建队列</strong></p>
<p>源码很长，但实际只有一个方法，逻辑比较清晰，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 开发者调用的方法 */</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_create_with_target(label, attr,</span><br><span class="line">			DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 内部实际调用方法 */</span></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span></span><br><span class="line">_dispatch_queue_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 1.初步判断</span></span><br><span class="line">	<span class="keyword">if</span> (!slowpath(dqa)) &#123;</span><br><span class="line">		dqa = _dispatch_get_default_queue_attr();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;do_vtable != DISPATCH_VTABLE(queue_attr)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.配置队列参数</span></span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> qos = _dispatch_priority_qos(dqa-&gt;dqa_qos_and_relpri);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123;</span><br><span class="line">		qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_MAINTENANCE) &#123;</span><br><span class="line">		qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">_dispatch_queue_attr_overcommit_t</span> overcommit = dqa-&gt;dqa_overcommit;</span><br><span class="line">	<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify both overcommit and "</span></span><br><span class="line">					<span class="string">"a non-global target queue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq &amp;&amp;</span><br><span class="line">			tq-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT) &#123;</span><br><span class="line">		<span class="comment">// Handle discrepancies between attr and target queue, attributes win</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_disabled;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">			<span class="keyword">dispatch_qos_t</span> tq_qos = _dispatch_priority_qos(tq-&gt;dq_priority);</span><br><span class="line">			tq = _dispatch_get_root_queue(tq_qos,</span><br><span class="line">					overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tq = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq) &#123;</span><br><span class="line">		<span class="comment">// target is a pthread or runloop root queue, setting QoS or overcommit</span></span><br><span class="line">		<span class="comment">// is disallowed</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify an overcommit attribute "</span></span><br><span class="line">					<span class="string">"and use this kind of target queue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (qos != DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify a QoS attribute "</span></span><br><span class="line">					<span class="string">"and use this kind of target queue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			 <span class="comment">// Serial queues default to overcommit!</span></span><br><span class="line">			overcommit = dqa-&gt;dqa_concurrent ?</span><br><span class="line">					_dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">					_dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">		<span class="keyword">if</span> (slowpath(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 初始化队列</span></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqa-&gt;dqa_inactive || dqa-&gt;dqa_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	<span class="keyword">dispatch_queue_flags_t</span> dqf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(<span class="built_in">queue</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;dqa_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (dqa-&gt;dqa_autorelease_frequency) &#123;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_NEVER:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_NEVER;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_ALWAYS;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		dqf |= DQF_LEGACY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (label) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line">		<span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">			dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line">			label = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqa-&gt;dqa_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqa-&gt;dqa_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">	dq-&gt;dq_priority = dqa-&gt;dqa_qos_and_relpri;</span><br><span class="line">	<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	<span class="keyword">if</span> (qos == QOS_CLASS_UNSPECIFIED) &#123;</span><br><span class="line">		<span class="comment">// legacy way of inherithing the QoS from the target</span></span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqa-&gt;dqa_inactive) &#123;</span><br><span class="line">		_dispatch_queue_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">"%s"</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码生成的流程图，不想看代码直接看图，下同：</p>
<p><img src="/uploads/concurrency-programming/Create_Queue.png" alt="Create_Queue"></p>
<p>根据流程图，这个方法的步骤如下：</p>
<ul>
<li>开发者调用 <code>dispatch_queue_create()</code> 方法之后，内部会调用 <code>_dispatch_queue_create_with_target()</code> 方法。</li>
<li>然后进行初步判断，多数情况下，我们是不会传队列类型的，都是穿 NULL，所以这里是个 slowpath。如果传了参数，但是不是规定的队列类型，系统会认为你是个智障，并抛出错误。</li>
<li>然后初始化一些配置项。主要是 target_queue，overcommit 项和 qos。target_queue 是依赖的目标队列，像任何队列提交的任务（block），最终都会放到目标队列中执行；支持 overcommit 时，每当想队列提交一个任务时，都会开一个新的线程处理，这样是为了避免单一线程任务太多而过载；qos 是队列优先级，之前已经说过。</li>
<li>然后进入判断分支。普通的串行队列的目标队列，就是一个支持 overcommit 的全局队列（对应 else 分支）；当前 tq 对象的引用计数为 DISPATCH_OBJECT_GLOBAL_REFCNT （永远不会释放）时，且还没有目标队列时，才可以设置 overcommit 项，而且当优先级为 DISPATCH_QOS_UNSPECIFIED 时，需要重置 tq （对应 if 分支）；其他情况（else if 分支）。</li>
<li>然后配置队列的标识，以方便在调试时找到自己的那个队列。</li>
<li>使用 <code>_dispatch_object_alloc</code> 方法申请一个 dispatch_queue_t 对象空间，dq。</li>
<li>根据传入的信息（并行 or 串行；活跃 or 非活跃）来初始化这个队列。并行队列的 width 会设置为 <code>DISPATCH_QUEUE_WIDTH_MAX</code> 即最大，不设限；串行的会设置为 1。</li>
<li>将上面获得配置项，目标队列，是否支持 overcommit，优先级和 dq 绑定。</li>
<li>返回这个队列。返回去还输出了一句信息，便于调试。</li>
</ul>
<p><strong>异步执行</strong></p>
<p>这个版本异步执行的代码，因为方法拆分很多，所以显得很乱。源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 开发者调用 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DISPATCH_OBJ_CONSUME_BIT;</span><br><span class="line"></span><br><span class="line">	_dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 内部调用，包一层，再深入调用 */</span></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_async(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_continuation_async2(dq, dc,</span><br><span class="line">			dc-&gt;dc_flags &amp; DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 根据 barrier 关键字区别串行还是并行，分两支 */</span></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_async2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">		<span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">		<span class="comment">// 串行</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 并行</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 并行又多了一层调用，就是这个方法 */</span></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_async_f2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq-&gt;dq_items_tail)) &#123;<span class="comment">// 少路径</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slowpath(!_dispatch_queue_try_acquire_async(dq))) &#123;<span class="comment">// 少路径</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 多路径</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_async_f_redirect(dq, dc,</span><br><span class="line">			_dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 主要用来重定向 */</span></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_async_f_redirect(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!slowpath(_dispatch_object_is_redirection(dou))) &#123;</span><br><span class="line">		dou._dc = _dispatch_async_redirect_wrap(dq, dou);</span><br><span class="line">	&#125;</span><br><span class="line">	dq = dq-&gt;do_targetq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the queue to redirect to</span></span><br><span class="line">	<span class="keyword">while</span> (slowpath(DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!fastpath(_dispatch_queue_try_acquire_async(dq))) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!dou._dc-&gt;dc_ctxt) &#123;</span><br><span class="line">			dou._dc-&gt;dc_ctxt = (<span class="keyword">void</span> *)</span><br><span class="line">					(<span class="keyword">uintptr_t</span>)_dispatch_queue_autorelease_frequency(dq);</span><br><span class="line">		&#125;</span><br><span class="line">		dq = dq-&gt;do_targetq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步异步最终都是调用的这个方法，将任务追加到队列中</span></span><br><span class="line">	dx_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... 省略一些调用层级，</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 核心方法，通过 dc_flags 参数区分了是 group，还是串行，还是并行 */</span></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_invoke_inline(<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">voucher_t</span> ov,</span><br><span class="line">		<span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">	dispatch_invoke_with_autoreleasepool(flags, &#123;</span><br><span class="line">		<span class="keyword">uintptr_t</span> dc_flags = dc-&gt;dc_flags;</span><br><span class="line">		_dispatch_continuation_voucher_adopt(dc, ov, dc_flags);</span><br><span class="line">		<span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123; <span class="comment">// 并行</span></span><br><span class="line">			dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dc1 = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(dc_flags &amp; DISPATCH_OBJ_GROUP_BIT)) &#123; <span class="comment">// group</span></span><br><span class="line">			_dispatch_continuation_with_group_invoke(dc);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 串行</span></span><br><span class="line">			_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">			_dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(dc1)) &#123;</span><br><span class="line">			_dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不想看代码，直接看图：</p>
<p><img src="/uploads/concurrency-programming/Dispatch_Asyn.png" alt="Dispatch_Asyn"></p>
<p>根据流程图描述一下过程：</p>
<ul>
<li>首先开发者调用 <code>dispatch_async()</code> 方法，然后内部创建了一个 <code>_dispatch_continuation_init</code> 队列，将 queue、block 这些信息和这个 dc 绑定起来。这过程中 copy 了 block。</li>
<li>然后经过了几个层次的调用，主要为了区分并行还是串行。</li>
<li>如果是串行（这种情况比较常见，所以是 fastpath），直接就 dx_push 了，其实就是讲任务追加到一个链表里面。</li>
<li>如果是并行，需要做重定向。之前我们说过，放到队列中的任务，最终都会以各种形式追加到目标队列里面。在 <code>_dispatch_async_f_redirect</code> 方法中，重新寻找依赖目标队列，然后追加过去。</li>
<li>经过一系列调用，我们会在 <code>_dispatch_continuation_invoke_inline</code> 方法里区分串行还是并行。因为这个方法会被频繁调用，所以定义成了内联函数。对于串行队列，我们使用信号量控制，执行前信号量置为 wait，执行完毕后发送 singal；对于调度组，我们会在执行完之后调用 <code>dispatch_group_leave</code>。</li>
<li>底层的线程池，是使用 pthread 维护的，所以最终都会使用 pthread 来处理这些任务。</li>
</ul>
<p><strong>同步执行</strong></p>
<p>同步执行，相对来说比较简单，源码如下 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 开发者调用 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_private_data(dq, work, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_sync_f(dq, work, _dispatch_Block_invoke(work));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 内部调用 */</span></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> dispatch_barrier_sync_f(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dq))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步执行，相对来说简单些，大体逻辑差不多。偷懒一下，就不画图了，直接描述：</p>
<ul>
<li>开发者使用 <code>dispatch_sync()</code> 方法，大多数路径，都会调用 <code>dispatch_sync_f()</code> 方法。</li>
<li>如果是串行队列，则通过 <code>dispatch_barrier_sync_f()</code> 方法来保证原子操作。</li>
<li>如果不是串行的（一般很少），我们使用 <code>_dispatch_introspection_sync_begin</code> 和 <code>_dispatch_sync_invoke_and_complete</code> 来保证同步。</li>
</ul>
<h5 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h5><p>dispatch_after 一般用于延后执行一些任务，可以用来代替 NSTimer，因为有时候 NSTimer 问题太多了。在后面的一章里，我会总体讲一下多线程中的问题，这里就不详细说了。一般我们这样来使用 dispatch_after ：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.dispatch"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="built_in">NSEC_PER_SEC</span> * <span class="number">2.0</span>f)),queue, ^&#123;</span><br><span class="line">        <span class="comment">// 2.0 second execute</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在做页面过渡时，刚进入到新的页面我们并不会立即更新一些 view，为了引起用户注意，我们会过会儿再进行更新，可以中此 API 来完成。</p>
<p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_after(<span class="keyword">dispatch_time_t</span> when, <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span><br><span class="line">		<span class="keyword">void</span> *ctxt, <span class="keyword">void</span> *handler, <span class="keyword">bool</span> block)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_timer_source_refs_t</span> dt;</span><br><span class="line">	<span class="keyword">dispatch_source_t</span> ds;</span><br><span class="line">	<span class="keyword">uint64_t</span> leeway, delta;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (when == DISPATCH_TIME_FOREVER) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_DEBUG</span></span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"dispatch_after called with 'when' == infinity"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	delta = _dispatch_timeout(when);</span><br><span class="line">	<span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (block) &#123;</span><br><span class="line">			<span class="keyword">return</span> dispatch_async(<span class="built_in">queue</span>, handler);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dispatch_async_f(<span class="built_in">queue</span>, ctxt, handler);</span><br><span class="line">	&#125;</span><br><span class="line">	leeway = delta / <span class="number">10</span>; <span class="comment">// &lt;rdar://problem/13447496&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (leeway &lt; NSEC_PER_MSEC) leeway = NSEC_PER_MSEC;</span><br><span class="line">	<span class="keyword">if</span> (leeway &gt; <span class="number">60</span> * NSEC_PER_SEC) leeway = <span class="number">60</span> * NSEC_PER_SEC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this function can and should be optimized to not use a dispatch source</span></span><br><span class="line">	ds = dispatch_source_create(&amp;_dispatch_source_type_after, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">queue</span>);</span><br><span class="line">	dt = ds-&gt;ds_timer_refs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">	<span class="keyword">if</span> (block) &#123;</span><br><span class="line">		_dispatch_continuation_init(dc, ds, handler, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_continuation_init_f(dc, ds, ctxt, handler, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// reference `ds` so that it doesn't show up as a leak</span></span><br><span class="line">	dc-&gt;dc_data = ds;</span><br><span class="line">	_dispatch_trace_continuation_push(ds-&gt;_as_dq, dc);</span><br><span class="line">	os_atomic_store2o(dt, ds_handler[DS_EVENT_HANDLER], dc, relaxed);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">int64_t</span>)when &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// wall clock</span></span><br><span class="line">		when = (<span class="keyword">dispatch_time_t</span>)-((<span class="keyword">int64_t</span>)when);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// absolute clock</span></span><br><span class="line">		dt-&gt;du_fflags |= DISPATCH_TIMER_CLOCK_MACH;</span><br><span class="line">		leeway = _dispatch_time_nano2mach(leeway);</span><br><span class="line">	&#125;</span><br><span class="line">	dt-&gt;dt_timer.target = when;</span><br><span class="line">	dt-&gt;dt_timer.interval = UINT64_MAX;</span><br><span class="line">	dt-&gt;dt_timer.deadline = when + leeway;</span><br><span class="line">	dispatch_activate(ds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_after()</code> 内部会调用 <code>_dispatch_after()</code> 方法，然后先判断延迟时间。如果为 <code>DISPATCH_TIME_FOREVER</code>（永远不执行），则会出现异常；如果为 0 则立即执行；否则的话会创建一个 dispatch_timer_source_refs_t 结构体指针，将上下文相关信息与之关联。然后使用 dispatch_source 相关方法，将定时器和 block 任务关联起来。定时器时间到时，取出 block 任务开始执行。</p>
<h5 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h5><p>如果我们有一段代码，在 App 生命周期内最好只初始化一次，这时候使用 dispatch_once 最好不过了。例如我们单例中经常这样用：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> BLDispatchManager *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[BLDispatchManager alloc] initPrivate];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有在定义 <code>NSDateFormatter</code> 时使用：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)todayDateString &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *formatter = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        formatter = [<span class="built_in">NSDateFormatter</span> new];</span><br><span class="line">        formatter.locale = [<span class="built_in">NSLocale</span> localeWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</span><br><span class="line">        formatter.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">8</span> * <span class="number">3600</span>];</span><br><span class="line">        formatter.dateFormat = <span class="string">@"yyyyMMdd"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这是很常用的一个代码片段，所以被加在了 Xcode 的 <a href="https://help.apple.com/xcode/mac/current/#/dev2b24f6f93" target="_blank" rel="noopener">code snippet</a> 中。</p>
<p>它的源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一个结构体，里面为当前的信号量、线程端口和指向下一个节点的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> *<span class="title">volatile</span> <span class="title">dow_next</span>;</span></span><br><span class="line">	dispatch_thread_event_s dow_event;</span><br><span class="line">	<span class="keyword">mach_port_t</span> dow_thread;</span><br><span class="line">&#125; *<span class="keyword">_dispatch_once_waiter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 我们调用的方法 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 实际执行的方法 */</span></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once_f(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_ONCE_INLINE_FASTPATH</span></span><br><span class="line">	<span class="keyword">if</span> (likely(os_atomic_load(val, acquire) == DLOCK_ONCE_DONE)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !DISPATCH_ONCE_INLINE_FASTPATH</span></span></span><br><span class="line">	<span class="keyword">return</span> dispatch_once_f_slow(val, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ONCE_SLOW_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">dispatch_once_f_slow(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_GATE_USE_FOR_DISPATCH_ONCE</span></span><br><span class="line">	<span class="keyword">dispatch_once_gate_t</span> l = (<span class="keyword">dispatch_once_gate_t</span>)val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_once_gate_tryenter(l)) &#123;</span><br><span class="line">		_dispatch_client_callout(ctxt, func);</span><br><span class="line">		_dispatch_once_gate_broadcast(l);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_once_gate_wait(l);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">_dispatch_once_waiter_t</span> <span class="keyword">volatile</span> *vval = (<span class="keyword">_dispatch_once_waiter_t</span>*)val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> <span class="title">dow</span> = &#123;</span> &#125;;</span><br><span class="line">	<span class="keyword">_dispatch_once_waiter_t</span> tail = &amp;dow, next, tmp;</span><br><span class="line">	<span class="keyword">dispatch_thread_event_t</span> event;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (os_atomic_cmpxchg(vval, <span class="literal">NULL</span>, tail, acquire)) &#123;</span><br><span class="line">		dow.dow_thread = _dispatch_tid_self();</span><br><span class="line">		_dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">		next = (<span class="keyword">_dispatch_once_waiter_t</span>)_dispatch_once_xchg_done(val);</span><br><span class="line">		<span class="keyword">while</span> (next != tail) &#123;</span><br><span class="line">			tmp = (<span class="keyword">_dispatch_once_waiter_t</span>)_dispatch_wait_until(next-&gt;dow_next);</span><br><span class="line">			event = &amp;next-&gt;dow_event;</span><br><span class="line">			next = tmp;</span><br><span class="line">			_dispatch_thread_event_signal(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_thread_event_init(&amp;dow.dow_event);</span><br><span class="line">		next = *vval;</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="keyword">if</span> (next == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (os_atomic_cmpxchgv(vval, next, tail, &amp;next, release)) &#123;</span><br><span class="line">				dow.dow_thread = next-&gt;dow_thread;</span><br><span class="line">				dow.dow_next = next;</span><br><span class="line">				<span class="keyword">if</span> (dow.dow_thread) &#123;</span><br><span class="line">					<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">					_dispatch_thread_override_start(dow.dow_thread, pp, val);</span><br><span class="line">				&#125;</span><br><span class="line">				_dispatch_thread_event_wait(&amp;dow.dow_event);</span><br><span class="line">				<span class="keyword">if</span> (dow.dow_thread) &#123;</span><br><span class="line">					_dispatch_thread_override_end(dow.dow_thread, val);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		_dispatch_thread_event_destroy(&amp;dow.dow_event);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不想看代码直接看图 (emmm… 根据逻辑画完图才发现，其实这个图也挺乱的，所以我将两个主分支用不同颜色标记处理)：</p>
<p><img src="/uploads/concurrency-programming/Dispatch_Once.png" alt="Dispatch_Once"></p>
<p>根据这个图，我来表述一下主要过程：</p>
<ul>
<li>我们调用 <code>dispatch_once()</code> 方法之后，内部多数情况下会调用 <code>dispatch_once_f_slow()</code> 方法，这个方法才是真正的执行方法。</li>
<li><p><code>os_atomic_cmpxchg(vval, NULL, tail, acquire)</code> 这个方法，执行过程实际是这个样子</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*vval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	*vval = tail = &amp;dow;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>我们初始化的 once_token,也就是 *vval 实际是 0，所以第一次执行时是返回 true 的。if() 中的这个方法是原子操作，也就是说，如果多个线程同时调用这个方法，只有一个线程会进入 true 的分支，其他都进入 else 分支。
</code></pre><ul>
<li><p>这里先说进入 true 分支。进入之后，会执行对应的 block，也就是对应的任务。然后 next 指向 <em>vval， </em>vval 标记为 <code>DISPATCH_ONCE_DONE</code>，即执行的是这样一个过程：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">next = (<span class="keyword">_dispatch_once_waiter_t</span>)_dispatch_once_xchg_done(val);</span><br><span class="line"><span class="comment">// 实际执行时这样的</span></span><br><span class="line">next = *vval;</span><br><span class="line">*vval = DISPATCH_ONCE_DONE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后 <code>tail = &amp;dow</code>。此时我们发现，原来的 <code>*vval = &amp;dow -&gt; next = *vval</code>，实际则是 <code>next = &amp;dow</code>，<strong>如果没有其他线程(或者调用）进入 else 分支，&amp;dow 实际没有改变，即 <code>tail == tmp</code></strong>。此时 <code>while (tail != tmp)</code> 是不会执行的，分支结束。</p>
</li>
<li>如果有其他线程(或者调用)进入了 else 分支，那么就已经生成了一个等待响应的链表。此时进入 &amp;dow 已经改变，成为了链表尾部，*vval 是链表头部。进入 while 循环后，开始遍历链表，依次发送信号进行唤起。</li>
<li>然后说进入 else 分支的这些调用。进入分支后，随即进入一个死循环，直到发现 *vval 已经标记为了 <code>DISPATCH_ONCE_DONE</code> 才跳出循环。</li>
<li>发现 *vval 不是 <code>DISPATCH_ONCE_DONE</code> 之后，会将这个节点追加到链表尾部，并调用信号量的 wait 方法，等待被唤起。</li>
</ul>
<p>以上为全部的执行过程。通过源码可以看出，使用的是 原子操作 + 信号量来保证 block 只会被执行多次，哪怕是在多线程情况下。</p>
<p>这样一个关于 <code>dispatch_once</code> 递归调用会产生死锁的现象，也就很好解释了。看下面代码：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchOnceTest &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> dispatchOnceTest];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面分析，在 block 执行完，并将 *vval 置为 <code>DISPATCH_ONCE_DONE</code> 之前，其他的调用都会进入 else 分支。第二次递归调用，信号量处于等待状态，需要等到第一个 block 执行完才能被唤起；但是第一个 block 所执行的内容就是进行第二次调用，这个任务被 wait 了，也即是说 block 永远执行不完。死锁就这样发生了。</p>
<h5 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h5><p>有时候没有时序性依赖的时候，我们会用 <code>dispatch_apply</code> 来代替 <code>for loop</code>。例如我们下载一组图片：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 使用 for loop */</span></span><br><span class="line">- (<span class="keyword">void</span>)downloadImages:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSURL</span> *&gt; *)imageURLs &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSURL</span> *imageURL <span class="keyword">in</span> imageURLs) &#123;</span><br><span class="line">        [<span class="keyword">self</span> downloadImageWithURL:imageURL];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** dispatch_apply */</span></span><br><span class="line">- (<span class="keyword">void</span>)downloadImages:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSURL</span> *&gt; *)imageURLs &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> downloadQueue = dispatch_queue_create(<span class="string">"com.bool.download"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_apply(imageURLs.count, downloadQueue, ^(size_t index) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *imageURL = imageURLs[index];</span><br><span class="line">        [<span class="keyword">self</span> downloadImageWithURL:imageURL];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行替换是需要注意几个问题：</p>
<ul>
<li>任务之间没有时序性依赖，谁先执行都可以。</li>
<li>一般在并发队列，并发执行任务时，才替换。串行队列替换没有意义。</li>
<li>如果数组中数据很少，或者每个任务执行时间很短，替换也没有意义。强行进行并发的消耗，可能比使用 for loop 还要多，并不能得到优化。</li>
</ul>
<p>至于原理，就不大篇幅讲了。大概是这个样子：这个方法是同步的，会阻塞当前线程，直到所有的 block 任务都完成。如果提交到并发队列，每个任务执行顺序是不一定的。</p>
<p>更多时候，我们执行下载任务，并不希望阻塞当前线程，这时我们可以使用 <code>dispatch_group</code>。</p>
<h5 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h5><p>当处理批量异步任务时，<code>dispatch_group</code> 是一个很好的选择。针对上面说的下载图片的例子，我们可以这样做：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadImages:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSURL</span> *&gt; *)imageURLs &#123;</span><br><span class="line">    dispatch_group_t taskGroup = dispatch_group_create();</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.group"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSURL</span> *imageURL <span class="keyword">in</span> imageURLs) &#123;</span><br><span class="line">        dispatch_group_enter(taskGroup);</span><br><span class="line">        <span class="comment">// 下载方法是异步的</span></span><br><span class="line">        [<span class="keyword">self</span> downloadImageWithURL:imageURL withQueue:queue completeHandler:^&#123;</span><br><span class="line">            dispatch_group_leave(taskGroup);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(taskGroup, queue, ^&#123;</span><br><span class="line">        <span class="comment">// all task finish</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 如果使用这个方法，内部执行异步任务，会立即到 dispatch_group_notify 方法中，因为是异步，系统认为已经执行完了。所以这个方法使用不多。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dispatch_group_async(taskGroup, queue, ^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于原理方面，和 <code>dispatch_async()</code> 方法类似，前面也提到。这里只说一段代码：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_group_async(dispatch_group_t dg, <span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_group_enter(dg);</span><br><span class="line">	dc-&gt;dc_data = dg;</span><br><span class="line">	_dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，调用了 <code>dispatch_group_enter(dg)</code> 方法进行标记，最终都会和 <code>dispatch_async()</code> 走到同样的方法里 <code>_dispatch_continuation_invoke_inline()</code>。在里面判断类型为 group，执行 task，执行结束后调用 <code>dispatch_group_leave((dispatch_group_t)dou)</code>，和之前的 enter 对应。</p>
<p>以上是 Dispatch Queues 内容的介绍，我们平时使用 GCD 的过程中，60% 都是使用的以上内容。</p>
<h4 id="2-Dispatch-Block"><a href="#2-Dispatch-Block" class="headerlink" title="2. Dispatch Block"></a>2. Dispatch Block</h4><p>在 iOS 8 中，Apple 为我们提供了新的 API，<code>Dispatch Block</code> 相关。虽然之前我们可以向 dispatch 传递 block 参数，作为任务，但是这里和之前的不一样。之前经常说，使用 <code>NSOperation</code> 创建的任务可以 cancel，使用 GCD 不可以。但是在 iOS 8 之后，可以 cancel 任务了。</p>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><ul>
<li><p>创建一个 block 并执行。</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	- (<span class="keyword">void</span>)dispatchBlockTest &#123;</span><br><span class="line">	    <span class="comment">// 不指定优先级</span></span><br><span class="line">	    dispatch_block_t dsBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">	        <span class="built_in">NSLog</span>(<span class="string">@"test block"</span>);</span><br><span class="line">	    &#125;);</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">// 指定优先级</span></span><br><span class="line">	    dispatch_block_t dsQosBlock = dispatch_block_create_with_qos_class(<span class="number">0</span>, QOS_CLASS_USER_INITIATED, <span class="number">-1</span>, ^&#123;</span><br><span class="line">	        <span class="built_in">NSLog</span>(<span class="string">@"test block"</span>);</span><br><span class="line">	    &#125;);</span><br><span class="line">	    </span><br><span class="line">	    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), dsBlock);</span><br><span class="line">	    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), dsQosBlock);</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">// 直接创建并执行</span></span><br><span class="line">	    dispatch_block_perform(<span class="number">0</span>, ^&#123;</span><br><span class="line">       		 <span class="built_in">NSLog</span>(<span class="string">@"test block"</span>);</span><br><span class="line">    	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>阻塞当前任务，等 block 执行完在继续执行。</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	- (<span class="keyword">void</span>)dispatchBlockTest &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.block"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_block_t dsBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"test block"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, dsBlock);</span><br><span class="line">    <span class="comment">// 等到 block 执行完</span></span><br><span class="line">    dispatch_block_wait(dsBlock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block was finished"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>block 执行完后，收到通知，执行其他任务</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	- (<span class="keyword">void</span>)dispatchBlockTest &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.block"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_block_t dsBlock = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"test block"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, dsBlock);</span><br><span class="line">    <span class="comment">// block 执行完收到通知</span></span><br><span class="line">    dispatch_block_notify(dsBlock, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block was finished,do other thing"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">	 <span class="built_in">NSLog</span>(<span class="string">@"execute first"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>对 block 进行 cancel 操作</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	- (<span class="keyword">void</span>)dispatchBlockTest &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.block"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_block_t dsBlock1 = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"test block1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_block_t dsBlock2 = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"test block2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, dsBlock1);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, dsBlock2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个 block 将会被 cancel，不执行</span></span><br><span class="line">    dispatch_block_cancel(dsBlock2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-Dispatch-Barriers"><a href="#3-Dispatch-Barriers" class="headerlink" title="3. Dispatch Barriers"></a>3. Dispatch Barriers</h4><p>Dispatch Barriers 可以理解为调度屏障，常用于多线程并发读写操作。例如：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> imageQueue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *imageArray;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.imageQueue = dispatch_queue_create(<span class="string">"com.bool.image"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">self</span>.imageArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 保证写入时不会有其他操作，写完之后到主线程更新 UI */</span></span><br><span class="line">- (<span class="keyword">void</span>)addImage:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.imageQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.imageArray addObject:image];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这里的 dispatch_sync 起到了 lock 的作用 */</span></span><br><span class="line">- (<span class="built_in">NSArray</span> &lt;<span class="built_in">UIImage</span> *&gt; *)images &#123;</span><br><span class="line">    __block <span class="built_in">NSArray</span> *imagesArray = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.imageQueue, ^&#123;</span><br><span class="line">        imagesArray = [<span class="keyword">self</span>.imageArray mutableCopy];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> imagesArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>转化成图可能好理解一些：</p>
<p><img src="/uploads/concurrency-programming/Dispatch_Barrier.png" alt="Dispatch_Barrier"></p>
<p><code>dispatch_barrier_async()</code> 的原理和 <code>dispatch_async()</code> 差不多，只不过设置的 flags 不一样：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_barrier_async(<span class="built_in">dispatch_queue_t</span> dq, dispatch_block_t work)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t dc = _dispatch_continuation_alloc();</span><br><span class="line">	<span class="comment">// 在 dispatch_async() 中只设置了 DISPATCH_OBJ_CONSUME_BIT</span></span><br><span class="line">	uintptr_t dc_flags = DISPATCH_OBJ_CONSUME_BIT | DISPATCH_OBJ_BARRIER_BIT;</span><br><span class="line"></span><br><span class="line">	_dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面都是 push 到队列中，然后，获取任务时一个死循环，在从队列中获取任务一个一个执行，如果判断 flag 为 barrier，终止循环，则单独执行这个任务。它后面的任务放入一个队列，等它执行完了再开始执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_queue_drain(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_invoke_context_t</span> dic,</span><br><span class="line">		<span class="keyword">dispatch_invoke_flags_t</span> flags, <span class="keyword">uint64_t</span> *owned_ptr, <span class="keyword">bool</span> serial_drain)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		...</span><br><span class="line">first_iteration:</span><br><span class="line">		dq_state = os_atomic_load(&amp;dq-&gt;dq_state, relaxed);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(_dq_state_is_suspended(dq_state))) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(orig_tq != dq-&gt;do_targetq)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (serial_drain || _dispatch_object_is_barrier(dc)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!serial_drain &amp;&amp; owned != DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!_dispatch_queue_try_upgrade_full_width(dq, owned)) &#123;</span><br><span class="line">					<span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">				&#125;</span><br><span class="line">				owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">			&#125;</span><br><span class="line">			next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">			<span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc)) &#123;</span><br><span class="line">				owned = <span class="number">0</span>;</span><br><span class="line">				dic-&gt;dic_deferred = dc;</span><br><span class="line">				<span class="keyword">goto</span> out_with_deferred;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">				<span class="comment">// we just ran barrier work items, we have to make their</span></span><br><span class="line">				<span class="comment">// effect visible to other sync work items on other threads</span></span><br><span class="line">				<span class="comment">// that may start coming in after this point, hence the</span></span><br><span class="line">				<span class="comment">// release barrier</span></span><br><span class="line">				os_atomic_xor2o(dq, dq_state, owned, release);</span><br><span class="line">				owned = dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(owned == <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc)) &#123;</span><br><span class="line">					<span class="comment">// sync "readers" don't observe the limit</span></span><br><span class="line">					_dispatch_queue_reserve_sync_width(dq);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_try_acquire_async(dq)) &#123;</span><br><span class="line">					<span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">				&#125;</span><br><span class="line">				owned = DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">			<span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc)) &#123;</span><br><span class="line">				owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">				_dispatch_sync_waiter_redirect_or_wake(dq,</span><br><span class="line">						DISPATCH_SYNC_WAITER_NO_UNLOCK, dc);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-Dispatch-Source"><a href="#4-Dispatch-Source" class="headerlink" title="4. Dispatch Source"></a>4. Dispatch Source</h4><p>关于 <code>dispatch_source</code> 我们使用的少之又少，他是 BSD 系统内核功能的包装，经常用来监测某些事件发生。例如监测断点的使用和取消。[这里][<a href="https://developer.apple.com/documentation/dispatch/dispatch_source_type_constants?language=objc]" target="_blank" rel="noopener">https://developer.apple.com/documentation/dispatch/dispatch_source_type_constants?language=objc]</a> 介绍了可以监测的事件：</p>
<ul>
<li>DISPATCH_SOURCE_TYPE_DATA_ADD ： 自定义事件</li>
<li>DISPATCH_SOURCE_TYPE_DATA_OR ： 自定义事件</li>
<li>DISPATCH_SOURCE_TYPE_MACH_RECV ： MACH 端口接收事件</li>
<li>DISPATCH_SOURCE_TYPE_MACH_SEND ： MACH 端口发送事件</li>
<li>DISPATCH_SOURCE_TYPE_PROC ： 进程相关事件</li>
<li>DISPATCH_SOURCE_TYPE_READ ： 文件读取事件</li>
<li>DISPATCH_SOURCE_TYPE_SIGNAL ： 信号相关事件</li>
<li>DISPATCH_SOURCE_TYPE_TIMER ： 定时器相关事件 </li>
<li>DISPATCH_SOURCE_TYPE_VNODE ： 文件属性修改事件</li>
<li>DISPATCH_SOURCE_TYPE_WRITE ： 文件写入事件</li>
<li>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE ： 内存压力事件</li>
</ul>
<p>例如我们可以通过下面代码，来监测断点的使用和取消：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t signalSource;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">dispatch_once_t</span> signalOnceToken;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	<span class="built_in">dispatch_once</span>(&amp;_signalOnceToken, ^&#123;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">        <span class="keyword">self</span>.signalSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, <span class="number">0</span>, queue);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.signalSource) &#123;</span><br><span class="line">            dispatch_source_set_event_handler(<span class="keyword">self</span>.signalSource, ^&#123;</span><br><span class="line">            	<span class="comment">// 点击一下断点，再取消断点，便会执行这里。</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"debug test"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            dispatch_resume(<span class="keyword">self</span>.signalSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有 <code>diapatch_after()</code> 就是依赖 <code>dispatch_source()</code> 来实现的。我们可以自己实现一个类似的定时器：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)customTimer &#123;</span><br><span class="line">    dispatch_source_t timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">    dispatch_source_set_timer(timerSource, dispatch_time(DISPATCH_TIME_NOW, <span class="number">5.0</span> * <span class="built_in">NSEC_PER_SEC</span>), <span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">5</span>);</span><br><span class="line">    dispatch_source_set_event_handler(timerSource, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"dispatch source timer"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.signalSource = timerSource;</span><br><span class="line">    dispatch_resume(<span class="keyword">self</span>.signalSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h5><p>使用 <code>dispatch_source</code> 时，大致过程是这样的：我们创建一个 source，然后加到队列中，并调用 <code>dispatch_resume()</code> 方法，便会从队列中唤起 source，执行对应的 block。下面是一个详细的流程图，我们结合这张图来说一下：</p>
<p><img src="/uploads/concurrency-programming/Dispatch_Source.png" alt="Dispatch_Source"></p>
<ul>
<li><p>创建一个 source 对象，过程和创建 queue 类似，所以后面一些操作，和操作 queue 很类似。</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t</span><br><span class="line">dispatch_source_create(dispatch_source_type_t dst, uintptr_t handle,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> mask, <span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_source_refs_t dr;</span><br><span class="line">	dispatch_source_t ds;</span><br><span class="line"></span><br><span class="line">	dr = dux_create(dst, handle, mask)._dr;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dr)) &#123;</span><br><span class="line">		<span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 申请内存空间</span></span><br><span class="line">	ds = _dispatch_object_alloc(DISPATCH_VTABLE(source),</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_source_s));</span><br><span class="line">	<span class="comment">// 初始化一个队列，然后配置参数，完全被当做一个 queue 来处理</span></span><br><span class="line">	_dispatch_queue_init(ds-&gt;_as_dq, DQF_LEGACY, <span class="number">1</span>,</span><br><span class="line">			DISPATCH_QUEUE_INACTIVE | DISPATCH_QUEUE_ROLE_INNER);</span><br><span class="line">	ds-&gt;dq_label = <span class="string">"source"</span>;</span><br><span class="line">	ds-&gt;do_ref_cnt++; <span class="comment">// the reference the manager queue holds</span></span><br><span class="line">	ds-&gt;ds_refs = dr;</span><br><span class="line">	dr-&gt;du_owner_wref = _dispatch_ptr2wref(ds);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slowpath(!dq)) &#123;</span><br><span class="line">		dq = _dispatch_get_root_queue(DISPATCH_QOS_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_retain((<span class="built_in">dispatch_queue_t</span> _Nonnull)dq);</span><br><span class="line">	&#125;</span><br><span class="line">	ds-&gt;do_targetq = dq;</span><br><span class="line">	<span class="keyword">if</span> (dr-&gt;du_is_timer &amp;&amp; (dr-&gt;du_fflags &amp; DISPATCH_TIMER_INTERVAL)) &#123;</span><br><span class="line">		_dispatch_source_set_interval(ds, handle);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_object_debug(ds, <span class="string">"%s"</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 event_handler。从源码中看出，用的是 <code>dispatch_continuation_t</code> 进行绑定，和之前绑定 queue 一样，将 block copy 了一份。后面执行的时候，拿出来用。然后将这个任务 push 到队列里。</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">void</span></span><br><span class="line">dispatch_source_set_event_handler(dispatch_source_t ds,</span><br><span class="line">		dispatch_block_t handler)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t dc;</span><br><span class="line">	<span class="comment">// 这里实际就是在初始化 dispatch_continuation_t</span></span><br><span class="line">	dc = _dispatch_source_handler_alloc(ds, handler, DS_EVENT_HANDLER, <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">// 经过一顿操作，将任务 push 到队列中。</span></span><br><span class="line">	_dispatch_source_set_handler(ds, DS_EVENT_HANDLER, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>调用 resume 方法，执行 source。一般新创建的都是暂停状态，这里判断是暂停状态，就开始唤起。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">void</span></span><br><span class="line">dispatch_resume(<span class="keyword">dispatch_object_t</span> dou)</span><br><span class="line">&#123;</span><br><span class="line">	DISPATCH_OBJECT_TFB(_dispatch_objc_resume, dou);</span><br><span class="line">	<span class="keyword">if</span> (dx_vtable(dou._do)-&gt;do_suspend) &#123;</span><br><span class="line">		dx_vtable(dou._do)-&gt;do_resume(dou._do, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后一步，是最核心的异步，唤起任务开始执行。之前的 queue 最终也是走到这样类似的一步，可以看返回类型都是 <code>dispatch_queue_wakeup_target_t</code>，基本是沿着 queue 的逻辑一路 copy 过来。这个方法，经过一系列判断，保证所有的 source 都会在正确的队列上面执行；如果队列和任务不对应，那么就返回正确的队列，重新派发让任务在正确的队列上执行。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">	DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_source_invoke2(<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_invoke_context_t</span> dic,</span><br><span class="line">		<span class="keyword">dispatch_invoke_flags_t</span> flags, <span class="keyword">uint64_t</span> *owned)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_source_t</span> ds = dou._ds;</span><br><span class="line">	<span class="keyword">dispatch_queue_wakeup_target_t</span> retq = DISPATCH_QUEUE_WAKEUP_NONE;</span><br><span class="line">	<span class="comment">// 获取当前 queue</span></span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = _dispatch_queue_get_current();</span><br><span class="line">	<span class="keyword">dispatch_source_refs_t</span> dr = ds-&gt;ds_refs;</span><br><span class="line">	<span class="keyword">dispatch_queue_flags_t</span> dqf;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// timer 事件处理</span></span><br><span class="line">	<span class="keyword">if</span> (dr-&gt;du_is_timer &amp;&amp;</span><br><span class="line">			os_atomic_load2o(ds, ds_timer_refs-&gt;dt_pending_config, relaxed)) &#123;</span><br><span class="line">		dqf = _dispatch_queue_atomic_flags(ds-&gt;_as_dq);</span><br><span class="line">		<span class="keyword">if</span> (!(dqf &amp; (DSF_CANCELED | DQF_RELEASED))) &#123;</span><br><span class="line">			<span class="comment">// timer has to be configured on the kevent queue</span></span><br><span class="line">			<span class="keyword">if</span> (dq != dkq) &#123;</span><br><span class="line">				<span class="keyword">return</span> dkq;</span><br><span class="line">			&#125;</span><br><span class="line">			_dispatch_source_timer_configure(ds);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否安装 source</span></span><br><span class="line">	<span class="keyword">if</span> (!ds-&gt;ds_is_installed) &#123;</span><br><span class="line">		<span class="comment">// The source needs to be installed on the kevent queue.</span></span><br><span class="line">		<span class="keyword">if</span> (dq != dkq) &#123;</span><br><span class="line">			<span class="keyword">return</span> dkq;</span><br><span class="line">		&#125;</span><br><span class="line">		_dispatch_source_install(ds, _dispatch_get_wlh(),</span><br><span class="line">				_dispatch_get_basepri());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否暂停，因为之前判断过，一般不可能走到这里</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(DISPATCH_QUEUE_IS_SUSPENDED(ds))) &#123;</span><br><span class="line">		<span class="comment">// Source suspended by an item drained from the source queue.</span></span><br><span class="line">		<span class="keyword">return</span> ds-&gt;do_targetq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否在</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_source_get_registration_handler(dr)) &#123;</span><br><span class="line">		<span class="comment">// The source has been registered and the registration handler needs</span></span><br><span class="line">		<span class="comment">// to be delivered on the target queue.</span></span><br><span class="line">		<span class="keyword">if</span> (dq != ds-&gt;do_targetq) &#123;</span><br><span class="line">			<span class="keyword">return</span> ds-&gt;do_targetq;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// clears ds_registration_handler</span></span><br><span class="line">		_dispatch_source_registration_callout(ds, dq, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> (!(dqf &amp; (DSF_CANCELED | DQF_RELEASED)) &amp;&amp;</span><br><span class="line">			os_atomic_load2o(ds, ds_pending_data, relaxed)) &#123;</span><br><span class="line">		<span class="comment">// 有些 source 还有未完成的数据，需要通过目标队列上的回调进行传送；有些 source 则需要切换到管理队列上去。</span></span><br><span class="line">		<span class="keyword">if</span> (dq == ds-&gt;do_targetq) &#123;</span><br><span class="line">			_dispatch_source_latch_and_call(ds, dq, flags);</span><br><span class="line">			dqf = _dispatch_queue_atomic_flags(ds-&gt;_as_dq);</span><br><span class="line">			prevent_starvation = dq-&gt;do_targetq ||</span><br><span class="line">					!(dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT);</span><br><span class="line">			<span class="keyword">if</span> (prevent_starvation &amp;&amp;</span><br><span class="line">					os_atomic_load2o(ds, ds_pending_data, relaxed)) &#123;</span><br><span class="line">				retq = ds-&gt;do_targetq;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ds-&gt;do_targetq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((dqf &amp; (DSF_CANCELED | DQF_RELEASED)) &amp;&amp; !(dqf &amp; DSF_DEFERRED_DELETE)) &#123;</span><br><span class="line">		<span class="comment">// 已经被取消的 source 需要从管理队列中卸载。卸载完成后，取消的 handler 需要交付到目标队列。</span></span><br><span class="line">		<span class="keyword">if</span> (!(dqf &amp; DSF_DELETED)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dr-&gt;du_is_timer &amp;&amp; !(dqf &amp; DSF_ARMED)) &#123;</span><br><span class="line">				<span class="comment">// timers can cheat if not armed because there's nothing left</span></span><br><span class="line">				<span class="comment">// to do on the manager queue and unregistration can happen</span></span><br><span class="line">				<span class="comment">// on the regular target queue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dq != dkq) &#123;</span><br><span class="line">				<span class="keyword">return</span> dkq;</span><br><span class="line">			&#125;</span><br><span class="line">			_dispatch_source_refs_unregister(ds, <span class="number">0</span>);</span><br><span class="line">			dqf = _dispatch_queue_atomic_flags(ds-&gt;_as_dq);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(dqf &amp; DSF_DEFERRED_DELETE)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!(dqf &amp; DSF_ARMED)) &#123;</span><br><span class="line">					<span class="keyword">goto</span> unregister_event;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// we need to wait for the EV_DELETE</span></span><br><span class="line">				<span class="keyword">return</span> retq ? retq : DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dq != ds-&gt;do_targetq &amp;&amp; (_dispatch_source_get_event_handler(dr) ||</span><br><span class="line">				_dispatch_source_get_cancel_handler(dr) ||</span><br><span class="line">				_dispatch_source_get_registration_handler(dr))) &#123;</span><br><span class="line">			retq = ds-&gt;do_targetq;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_dispatch_source_cancel_callout(ds, dq, flags);</span><br><span class="line">			dqf = _dispatch_queue_atomic_flags(ds-&gt;_as_dq);</span><br><span class="line">		&#125;</span><br><span class="line">		prevent_starvation = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_unote_needs_rearm(dr) &amp;&amp;</span><br><span class="line">			!(dqf &amp; (DSF_ARMED|DSF_DELETED|DSF_CANCELED|DQF_RELEASED))) &#123;</span><br><span class="line">		<span class="comment">// 需要在管理队列进行 rearm 的</span></span><br><span class="line">		<span class="keyword">if</span> (dq != dkq) &#123;</span><br><span class="line">			<span class="keyword">return</span> dkq;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(dqf &amp; DSF_DEFERRED_DELETE)) &#123;</span><br><span class="line">			<span class="comment">// 如果我们可以直接注销，不需要 resume</span></span><br><span class="line">			<span class="keyword">goto</span> unregister_event;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(DISPATCH_QUEUE_IS_SUSPENDED(ds))) &#123;</span><br><span class="line">			<span class="comment">// 如果 source 已经暂停，不需要在管理队列 rearm</span></span><br><span class="line">			<span class="keyword">return</span> ds-&gt;do_targetq;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (prevent_starvation &amp;&amp; dr-&gt;du_wlh == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">			<span class="keyword">return</span> ds-&gt;do_targetq;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!_dispatch_source_refs_resume(ds))) &#123;</span><br><span class="line">			<span class="keyword">goto</span> unregister_event;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!prevent_starvation &amp;&amp; _dispatch_wlh_should_poll_unote(dr)) &#123;</span><br><span class="line">			_dispatch_event_loop_drain(KEVENT_FLAG_IMMEDIATE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>还有一些其他的方法，这里就不介绍了。有兴趣的可以看源码，太多了。
</code></pre><h4 id="5-Dispatch-I-O"><a href="#5-Dispatch-I-O" class="headerlink" title="5. Dispatch I/O"></a>5. Dispatch I/O</h4><p>我们可以使用 Dispatch I/O 快速读取一些文件，例如这样 ：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)readFile &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *filePath = <span class="string">@"/.../青花瓷.m"</span>;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.readfile"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_fd_t fd = open(filePath.UTF8String, O_RDONLY,<span class="number">0</span>);</span><br><span class="line">    dispatch_io_t fileChannel = dispatch_io_create(DISPATCH_IO_STREAM, fd, queue, ^(<span class="keyword">int</span> error) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *fileData = [<span class="built_in">NSMutableData</span> new];</span><br><span class="line">    dispatch_io_set_low_water(fileChannel, SIZE_MAX);</span><br><span class="line">    dispatch_io_read(fileChannel, <span class="number">0</span>, SIZE_MAX, queue, ^(<span class="keyword">bool</span> done, dispatch_data_t  _Nullable data, <span class="keyword">int</span> error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error == <span class="number">0</span> &amp;&amp; dispatch_data_get_size(data) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [fileData appendData:(<span class="built_in">NSData</span> *)data];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithData:fileData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"read file completed, string is :\n %@"</span>,str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrencyTest[<span class="number">41479</span>:<span class="number">5357296</span>] read file completed, string is :</span><br><span class="line"> 天青色等烟雨 而我在等你</span><br><span class="line">月色被打捞起 晕开了结局</span><br></pre></td></tr></table></figure>
<p>如果读取大文件，我们可以进行切片读取，将文件分割多个片，放在异步线程中并发执行，这样会比较快一些。</p>
<p>关于源码，简单看了一下，调度逻辑和之前的任务类似。然后读写操作，是调用的一些底层接口实现，这里就偷懒一下不详细说了。使用 Dispatch I/O，多数情况下是为了并发读取一个大文件，提高读取速度。</p>
<h4 id="6-Other"><a href="#6-Other" class="headerlink" title="6. Other"></a>6. Other</h4><p>上面已经讲了概览图中的大部分东西，还有一些未讲述，这里简单描述一下：</p>
<ul>
<li><p>dispatch_object。GCD 用 C 函数实现的对象，不能通过集成 dispatch 类实现，也不能用 alloc 方法初始化。GCD 针对 dispatch_object 提供了一些接口，我们使用这些接口可以处理一些内存事件、取消和暂停操作、定义上下文和处理日志相关工作。dispatch_object 必须要手动管理内存，不遵循垃圾回收机制。</p>
</li>
<li><p>dispatch_time。在 GCD 中使用的时间对象，可以创建自定义时间，也可以使用 <code>DISPATCH_TIME_NOW</code>、<code>DISPATCH_TIME_FOREVER</code> 这两个系统给出的时间。</p>
</li>
</ul>
<p>以上为 GCD 相关知识，这次使用的源码版本为最新版本 —— <strong>912.30.4.tar.gz</strong>，和之前看的版本代码差距很大，因为代码量的增加，新版本代码比较乱，不过基本原理还是差不多的。曾经我一度认为，最上面的是最新版本…</p>
<h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><p>Operations 也是我们在并发编程中常用的一套 API，根据 <a href="https://developer.apple.com/documentation/foundation/nsinvocationoperation?language=objc" target="_blank" rel="noopener">官方文档</a> 划分的结构如下图：</p>
<p><img src="/uploads/concurrency-programming/Operations 结构图.png" alt="Operations 结构图"></p>
<p>其中 <code>NSBlockOperation</code> 和 <code>NSInvocationOperation</code> 是基于 <code>NSOperation</code> 的子类化实现。相对于 GCD，Operations 的原理要稍微好理解一些，下面就将用法和原理介绍一下。</p>
<h4 id="1-NSOperation"><a href="#1-NSOperation" class="headerlink" title="1. NSOperation"></a>1. NSOperation</h4><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p>每一个 operation 可以认为是一个 task。<code>NSOperation</code> 本事是一个抽象类，使用前需子类化。幸运的是，Apple 为我们实现了两个子类：<code>NSInvocationOperation</code>、<code>NSBlockOperation</code>。我们也可以自己去定义一个 operation。下面介绍一下基本使用：</p>
<ul>
<li><p>创建一个 <code>NSInvocationOperation</code> 对象并在当前线程执行.</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *invocationOperation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(log) object:<span class="literal">nil</span>];</span><br><span class="line">   [invocationOperation start];</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个 <code>NSBlockOperation</code> 对象并执行 （每个 block 不一定会在当前线程，也不一定在同一线程执行）.</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *blockOpeartion = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"block operation"</span>);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 可以添加多个 block</span></span><br><span class="line">   [blockOpeartion addExecutionBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"other block opeartion"</span>);</span><br><span class="line">   &#125;];</span><br><span class="line">   [blockOpeartion start];</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义一个 Operation。当我们不需要操作状态的时候，只需要实现 <code>main()</code> 方法即可。需要操作状态的后面再说.</p>
  <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BLOpeartion</span> : <span class="title">NSOperation</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BLOpeartion</span></span></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line"> 	  <span class="built_in">NSLog</span>(<span class="string">@"BLOperation main method"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">   	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">  	 	BLOperation *blOperation = [BLOperation new];</span><br><span class="line">   	[blOperation start];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>每个 operation 之间设置依赖.</p>
   <figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *blockOpeartion1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"block operation1"</span>);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="built_in">NSBlockOperation</span> *blockOpeartion2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"block operation2"</span>);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="comment">// 2 需要在 1 执行完之后再执行。</span></span><br><span class="line">  [blockOpeartion2 addDependency:blockOpeartion1];</span><br></pre></td></tr></table></figure>
</li>
<li><p>与队列相关的使用，后面再说.</p>
</li>
</ul>
<h5 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h5><p><code>NSOperation</code> 内置了一个强大的状态机，一个 operation 从初始化到执行完毕这一生命周期，对应了各种状态。下面是在 <a href="https://developer.apple.com/videos/play/wwdc2015/226/" target="_blank" rel="noopener">WWDC 2015 Advanced NSOperations</a> 出现的一张图：</p>
<p><img src="/uploads/concurrency-programming/opeartion_status.png" alt="opeartion_status"></p>
<p>operation 一开始是 Pending 状态，代表即将进入 Ready；进入 Ready 之后，代表任务可以执行；然后进入 Executing 状态；最后执行完成，进入 Finished 状态。过程中，除了 Finished 状态，在其他几个状态中都可以进行 Cancelled。</p>
<p><code>NSOperation</code> 并没有开源。但是 swift 开源了，在 swift 中它叫 <code>Opeartion</code>，我们可以在 <a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/Operation.swift" target="_blank" rel="noopener">这里</a> 找到他的源码。我这里 copy 了一份：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lock = <span class="type">NSLock</span>()</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">weak</span> <span class="keyword">var</span> _queue: <span class="type">OperationQueue</span>?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认几个状态都是 false</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _cancelled = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _executing = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _finished = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _ready = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个集合来保存依赖它的对象</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _dependencies = <span class="type">Set</span>&lt;<span class="type">Operation</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一些 dispatch_group 对象，来管理 operation 以及其依赖对象的 执行。</span></span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _group = <span class="type">DispatchGroup</span>()</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _depGroup = <span class="type">DispatchGroup</span>()</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _groups = [<span class="type">DispatchGroup</span>]()</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">        _group.enter()</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> _leaveGroups<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// assumes lock is taken</span></span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">        _groups.forEach() &#123; $<span class="number">0</span>.leave() &#125;</span><br><span class="line">        _groups.removeAll()</span><br><span class="line">        _group.leave()</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认实现的 start 方法中，执行 main 方法，线程安全，下同。执行前后设置 _executing。</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !isCancelled &#123;</span><br><span class="line">            lock.lock()</span><br><span class="line">            _executing = <span class="literal">true</span></span><br><span class="line">            lock.unlock()</span><br><span class="line">            main()</span><br><span class="line">            lock.lock()</span><br><span class="line">            _executing = <span class="literal">false</span></span><br><span class="line">            lock.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">        finish()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认实现的 finish 方法中，标记 _finished 状态。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">finish</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        _finished = <span class="literal">true</span></span><br><span class="line">        _leaveGroups()</span><br><span class="line">        lock.unlock()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> queue = _queue &#123;</span><br><span class="line">            queue._operationFinished(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// main 方法默认空，需要子类去实现。</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 cancel 方法后，只是标记状态，具体操作在 main 中，调用 cancel 后也被认为是 finish。</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        _cancelled = <span class="literal">true</span></span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 几个状态的 get 方法，省略 */</span>    </span><br><span class="line">     ...</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为异步任务，默认为 false。这个方法在 OC 中永远不会去实现</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> isAsynchronous: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置依赖，即将 operation 放到集合中</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addDependency</span><span class="params">(<span class="number">_</span> op: Operation)</span></span> &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        _dependencies.insert(op)</span><br><span class="line">        op.lock.lock()</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">        _depGroup.enter()</span><br><span class="line">        op._groups.append(_depGroup)</span><br><span class="line">#endif</span><br><span class="line">        op.lock.unlock()</span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认队列优先级为  normal</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> queuePriority: <span class="type">QueuePriority</span> = .normal</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> completionBlock: (() -&gt; <span class="type">Void</span>)?</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">waitUntilFinished</span><span class="params">()</span></span> &#123;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">        _group.wait()</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程优先级</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> threadPriority: <span class="type">Double</span> = <span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// - Note: Quality of service is not directly supported here since there are not qos class promotions available outside of darwin targets.</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> qualityOfService: <span class="type">QualityOfService</span> = .<span class="keyword">default</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> _waitUntilReady<span class="params">()</span></span> &#123;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">        _depGroup.wait()</span><br><span class="line">#endif</span><br><span class="line">        _ready = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，具体过程可以直接看注释，就不另说了。除此之外，我们可以看出，<code>Operation</code> 总很多方法造作都加了锁，说明这个类是线程安全的，当我们对 <code>NSOperation</code> 进行子类化时，重写方法要注意线程暗转问题。</p>
<h4 id="2-NSOperationQueue"><a href="#2-NSOperationQueue" class="headerlink" title="2. NSOperationQueue"></a>2. NSOperationQueue</h4><p><code>NSOperation</code> 的很多花式操作，都是结合着 <code>NSOperationQueue</code> 进行的。我们在使用的时候，也是两者结合着使用。下面对其进行详细分析。</p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul>
<li>operation 放到 queue 中不用在手动调用 <code>start</code> 方法去执行，operation 会自动执行。</li>
<li>queue 可以设置最大并发数，当并发数量设置为 1 时，为串行队列；默认并发数量为无限大。</li>
<li>queue 可以通过设置 <code>suspended</code> 属性来<strong>暂停或者启动还未执行的 operation</strong>。</li>
<li>queue 可以通过调用 <code>-[cancelAllOperations]</code> 方法来取消队列中的任务。</li>
<li>queue 可以通过 <code>mainQueue</code> 方法来回到主队列（主线程）；可以通过 <code>currentQueue</code> 方法来获取当前队列。</li>
<li>更多方法，请参考 <a href="https://developer.apple.com/documentation/foundation/nsoperationqueue?language=objc" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<p>使用例子：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testOperationQueue &#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *operationQueue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line">    <span class="comment">// 设置最大并发数量为 3</span></span><br><span class="line">    [operationQueue setMaxConcurrentOperationCount:<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *invocationOpeartion = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(log) object:<span class="literal">nil</span>];</span><br><span class="line">    [operationQueue addOperation:invocationOpeartion];</span><br><span class="line">    </span><br><span class="line">    [operationQueue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block operation"</span>);</span><br><span class="line">        <span class="comment">// 回到主线程执行任务</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"execute in main thread"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暂停还未开始执行的任务</span></span><br><span class="line">    operationQueue.suspended = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消所有任务</span></span><br><span class="line">    [operationQueue cancelAllOperations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个问题要特别说明一下：</p>
<p><strong><code>NSOperationQueue</code> 和 GCD 中的队列不同。GCD 中的队列是遵循 FIFO 原则，先加入队列的先执行；<code>NSOperationQueue</code> 中的任务，根据谁先进入到 <code>Ready</code> 状态，谁先执行。如果有多个任务同时达到 <code>Ready</code> 状态，那么根据优先级来执行。</strong></p>
<p>例如下面的任务中，4 先到达了 <code>Ready</code> 状态，4 先执行。并不是按照 1，2，3… 顺序执行。</p>
<p><img src="/uploads/concurrency-programming/Operation_Queue.png" alt="Operation_Queue"></p>
<h5 id="基本原理-3"><a href="#基本原理-3" class="headerlink" title="基本原理"></a>基本原理</h5><p>我们依然是在 swift 中找到相关源码，然后来进行分析：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认最大并发数量为 int 最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">OperationQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> defaultMaxConcurrentOperationCount: <span class="type">Int</span> = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个 list 来保存各个优先级的 operation。调用其中的方法对 operation 进行增删等操作。</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">struct</span> _OperationList </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> veryLow = [<span class="type">Operation</span>]()</span><br><span class="line">    <span class="keyword">var</span> low = [<span class="type">Operation</span>]()</span><br><span class="line">    <span class="keyword">var</span> normal = [<span class="type">Operation</span>]()</span><br><span class="line">    <span class="keyword">var</span> high = [<span class="type">Operation</span>]()</span><br><span class="line">    <span class="keyword">var</span> veryHigh = [<span class="type">Operation</span>]()</span><br><span class="line">    <span class="keyword">var</span> all = [<span class="type">Operation</span>]()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> operation: Operation)</span></span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> operation: Operation)</span></span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">Operation</span>? &#123; ... &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> all.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Operation)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> all.<span class="built_in">map</span>(transform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationQueue</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 使用一个信号量的来控制并发数量</span></span><br><span class="line">    <span class="keyword">var</span> __concurrencyGate: <span class="type">DispatchSemaphore</span>?</span><br><span class="line">    <span class="keyword">var</span> __underlyingQueue: <span class="type">DispatchQueue</span>? &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> key = <span class="type">OperationQueue</span>.<span class="type">OperationQueueKey</span></span><br><span class="line">            oldValue?.setSpecific(key: key, value: <span class="literal">nil</span>)</span><br><span class="line">            __underlyingQueue?.setSpecific(key: key, value: <span class="type">Unmanaged</span>.passUnretained(<span class="keyword">self</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _underlyingQueue: <span class="type">DispatchQueue</span> &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> queue = __underlyingQueue &#123;</span><br><span class="line">            lock.unlock()</span><br><span class="line">            <span class="keyword">return</span> queue</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 信号量的值根据最大并发数量来确定。每当执行一个任务，wait 信号量减一，signal 信号量加一，当信号量为0时，一直等待，直接大于 0 才会正常执行。</span></span><br><span class="line">            <span class="keyword">if</span> maxConcurrentOperationCount == <span class="number">1</span> &#123;</span><br><span class="line">                attr = []</span><br><span class="line">                __concurrencyGate = <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                attr = .concurrent</span><br><span class="line">                <span class="keyword">if</span> maxConcurrentOperationCount != <span class="type">OperationQueue</span>.defaultMaxConcurrentOperationCount &#123;</span><br><span class="line">                    __concurrencyGate = <span class="type">DispatchSemaphore</span>(value:maxConcurrentOperationCount)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: effectiveName, attributes: attr)</span><br><span class="line">            <span class="keyword">if</span> _suspended &#123;</span><br><span class="line">                queue.suspend()</span><br><span class="line">            &#125;</span><br><span class="line">            __underlyingQueue = queue</span><br><span class="line">            lock.unlock()</span><br><span class="line">            <span class="keyword">return</span> queue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队列，每个任务执行时拿出队列执行</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> _dequeueOperation<span class="params">()</span></span> -&gt; <span class="type">Operation</span>? &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">let</span> op = _operations.dequeue()</span><br><span class="line">        lock.unlock()</span><br><span class="line">        <span class="keyword">return</span> op</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addOperation</span><span class="params">(<span class="number">_</span> op: Operation)</span></span> &#123;</span><br><span class="line">        addOperations([op], waitUntilFinished: <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要执行方法。先判断 operation 是否 ready，处于 ready 后判断是否 cancel。没有 cancel 则执行。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> _runOperation<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> op = _dequeueOperation() &#123;</span><br><span class="line">            <span class="keyword">if</span> !op.isCancelled &#123;</span><br><span class="line">                op._waitUntilReady()</span><br><span class="line">                <span class="keyword">if</span> !op.isCancelled &#123;</span><br><span class="line">                    op.start()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将任务加到队列中。如果不指定任务优先级，执行的还快一些。否则需要对不同优先级进行划分，然后执行</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addOperations</span><span class="params">(<span class="number">_</span> ops: [Operation], waitUntilFinished wait: Bool)</span></span> &#123;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">        <span class="keyword">var</span> waitGroup: <span class="type">DispatchGroup</span>?</span><br><span class="line">        <span class="keyword">if</span> wait &#123;</span><br><span class="line">            waitGroup = <span class="type">DispatchGroup</span>()</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="comment">// 将 operation 依依加入 list，根据优先级保存到不同数组中</span></span><br><span class="line">        ops.forEach &#123; (operation: <span class="type">Operation</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            operation._queue = <span class="keyword">self</span></span><br><span class="line">            _operations.insert(operation)</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历执行，使用了 diapatch group，控制 enter 和 leave</span></span><br><span class="line">        ops.forEach &#123; (operation: <span class="type">Operation</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> group = waitGroup &#123;</span><br><span class="line">                group.enter()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过信号量来控制并发数量</span></span><br><span class="line">            <span class="keyword">let</span> block = <span class="type">DispatchWorkItem</span>(flags: .enforceQoS) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> sema = <span class="keyword">self</span>._concurrencyGate &#123;</span><br><span class="line">                    sema.wait()</span><br><span class="line">                    <span class="keyword">self</span>._runOperation()</span><br><span class="line">                    sema.signal()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>._runOperation()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> group = waitGroup &#123;</span><br><span class="line">                    group.leave()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _underlyingQueue.async(group: queueGroup, execute: block)</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> group = waitGroup &#123;</span><br><span class="line">            group.wait()</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> _operationFinished<span class="params">(<span class="number">_</span> operation: Operation)</span></span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addOperation</span><span class="params">(<span class="number">_</span> block: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>) &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回值不一定准确</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> operations: [<span class="type">Operation</span>] &#123; ... &#125;</span><br><span class="line">    <span class="comment">// 返回值不一定准确</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> operationCount: <span class="type">Int</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> maxConcurrentOperationCount: <span class="type">Int</span> = <span class="type">OperationQueue</span>.defaultMaxConcurrentOperationCount</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// suppend 属性的 get &amp; set 方法。默认不暂停</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _suspended = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> isSuspended: <span class="type">Bool</span> &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// operation 在获取系统资源时的优先级</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> qualityOfService: <span class="type">QualityOfService</span> = .<span class="keyword">default</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次调用每个 operation 的 cancel 方法</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">cancelAllOperations</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">waitUntilAllOperationsAreFinished</span><span class="params">()</span></span> &#123;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">        queueGroup.wait()</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">OperationQueueKey</span> = <span class="type">DispatchSpecificKey</span>&lt;<span class="type">Unmanaged</span>&lt;<span class="type">OperationQueue</span>&gt;&gt;()</span><br><span class="line">    <span class="comment">// 通过使用 GCD 中的 getSpecific 方法获取当前队列</span></span><br><span class="line">    <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">current</span>: <span class="title">OperationQueue</span>? </span>&#123;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEPLOYMENT_ENABLE_LIBDISPATCH</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> specific = <span class="type">DispatchQueue</span>.getSpecific(key: <span class="type">OperationQueue</span>.<span class="type">OperationQueueKey</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> _CFIsMainThread() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">OperationQueue</span>.main</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> specific.takeUnretainedValue()</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义主队列，最大并发数量为 1，获取主队列时将这个值返回  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> _main = <span class="type">OperationQueue</span>(_queue: .main, maxConcurrentOperations: <span class="number">1</span>)    </span><br><span class="line">    <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">main</span>: <span class="title">OperationQueue</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很长，但是简单，可以直接通过注释来理解了。这里屡一下：</p>
<ul>
<li>将每个 operation 加入到队列时，会根据优先级将 operation 分类存入 list 中，根据优先级执行。如果都不设置优先级，执行起来比较快一些。</li>
<li>加入到队列，会遍历每个 operation，取出进入 <code>Ready</code> 状态且没被 <code>Cancel</code> 的依次执行。</li>
<li>通过 <code>concurrencyGate</code> 这个信号量来控制并发数量。每当执行一个任务，wait 信号量减一，signal 信号量加一，当信号量为0时，一直等待，直接大于 0 才会正常执行。</li>
<li>每个方法中基本都加了锁，来保证线程安全。</li>
</ul>
<h5 id="自定义-NSOperation"><a href="#自定义-NSOperation" class="headerlink" title="自定义 NSOperation"></a>自定义 NSOperation</h5><p>之前说了自定义普通的 <code>NSOperation</code>，只需要重写 <code>main</code> 方法就可以了,但是因为我们没有处理并发情况，线程执行结束操作，KVO 机制，所以这种普通的不建议用来做并发任务。下面讲一下如何自定义并行的 <code>NSOperation</code>。</p>
<p>必须要实现的一些方法：</p>
<ul>
<li><code>start</code> 方法，在你想要执行的线程中调用此方法。<strong>不需要调用 super 方法</strong>。</li>
<li><code>main</code> 方法，在 <code>start</code> 方法中调用，任务主体。</li>
<li><code>isExecuting</code> 方法，是否正在执行，要实现 KVO 机制。</li>
<li><code>isConcurrent</code> 方法，已经弃用，由 <code>isAsynchronous</code> 来代替。</li>
<li><code>isAsynchronous</code> 方法，在并发任务中，需要返回 YES。</li>
</ul>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BLOperation</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> executing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> finished;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BLOperation</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> executing;</span><br><span class="line"><span class="keyword">@synthesize</span> finished;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        executing = <span class="literal">NO</span>;</span><br><span class="line">        finished = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">        finished = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(main) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">    executing = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main begin"</span>);</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"custom operation"</span>);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"currentThread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"mainThread    = %@"</span>, [<span class="built_in">NSThread</span> mainThread]);</span><br><span class="line">            </span><br><span class="line">            [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">            [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">            executing = <span class="literal">NO</span>;</span><br><span class="line">            finished = <span class="literal">YES</span>;</span><br><span class="line">            [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">            [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"exception is %@"</span>, exception);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> executing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> finished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isAsynchronous &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>关于 <code>NSBlockOpeartion</code>，主要实现了 <code>main</code> 方法，然后用一个数组保存加进来的其他 block，源码如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">open <span class="keyword">class</span> BlockOperation: Operation &#123;</span><br><span class="line">    typealias ExecutionBlock = () -&gt; Void</span><br><span class="line">    internal var _block: () -&gt; Void</span><br><span class="line">    internal var _executionBlocks = [ExecutionBlock]()</span><br><span class="line">    </span><br><span class="line">    public init(block: @escaping () -&gt; Void) &#123;</span><br><span class="line">        _block = block</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override open func main() &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        let block = _block</span><br><span class="line">        let executionBlocks = _executionBlocks</span><br><span class="line">        lock.unlock()</span><br><span class="line">        block()</span><br><span class="line">        executionBlocks.forEach &#123; $<span class="number">0</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func addExecutionBlock(_ block: @escaping () -&gt; Void) &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        _executionBlocks.append(block)</span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open var executionBlocks: [() -&gt; Void] &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        let blocks = _executionBlocks</span><br><span class="line">        lock.unlock()</span><br><span class="line">        <span class="keyword">return</span> blocks</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>NSOperation</code> 的相关东西，到此结束。</p>
<h3 id="在开发中的一些问题"><a href="#在开发中的一些问题" class="headerlink" title="在开发中的一些问题"></a>在开发中的一些问题</h3><p>相对于 API 的使用和基本原理的了解，我认为最重要的还是这一部分。毕竟我们还是要拿这些东西来开发的。并发编程中有很多坑，这里简单介绍一些。</p>
<h4 id="1-NSNotification-与多线程问题"><a href="#1-NSNotification-与多线程问题" class="headerlink" title="1. NSNotification 与多线程问题"></a>1. NSNotification 与多线程问题</h4><p>我们都知道，<code>NSNotification</code> 在哪个线程 post，最终就会在哪个线程执行。如果我们不是在主线程 post 的，但是却在主线程接收的，而且我们期望 selector 在主线程执行。这时候我们需要注意下，在 selector 需要 dispatch 到主线程才可以。当然你也可以使用 <code>addObserverForName:object:queue:usingBlock:</code> 来指定执行 block 的 queue。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BLPostNotification</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotification &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.bool.post.notification"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 从非主线程发送通知 （通知名字最好定义成一个常量）</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"downloadImage"</span> object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ImageViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(show) name:<span class="string">@"downloadImage"</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showImage &#123;</span><br><span class="line">    <span class="comment">// 需要 dispatch 到主线程更新 UI</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// update UI</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="2-NSTimer-与多线程问题"><a href="#2-NSTimer-与多线程问题" class="headerlink" title="2. NSTimer 与多线程问题"></a>2. NSTimer 与多线程问题</h4><p>使用 <code>NSTimer</code> 时，在哪个线程生成的 timer，就在哪个线程销毁，否则会有意想不到的结果。官方这样描述的：</p>
<blockquote>
<p>However, for a repeating timer, you must invalidate the timer object yourself by calling its invalidate method. Calling this method requests the removal of the timer from the current run loop; as a result, <strong>you should always call the invalidate method from the same thread on which the timer was installed</strong>. </p>
</blockquote>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BLTimerTest</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BLTimerTest</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _queue = dispatch_queue_create(<span class="string">"com.bool.timer.test"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)installTimer &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span>f repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"test timer"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)clearTimer &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.timer isValid]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">            <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="3-Dispatch-Once-死锁问题"><a href="#3-Dispatch-Once-死锁问题" class="headerlink" title="3. Dispatch Once 死锁问题"></a>3. Dispatch Once 死锁问题</h4><p>在开发中，我们经常使用 <code>dispatch_once</code>，但是递归调用会造成死锁。例如下面这样：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchOnceTest &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> dispatchOnceTest];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于为什么会死锁，上文介绍 Dispatch Once 的时候已经说明了，这里就不多做介绍了。提醒一下使用的时候要注意，不要造成递归调用。</p>
<h4 id="4-Dispatch-Group-问题"><a href="#4-Dispatch-Group-问题" class="headerlink" title="4. Dispatch Group 问题"></a>4. Dispatch Group 问题</h4><p>在使用 <code>dispatch_group</code> 的时候，<code>dispatch_group_enter(taskGroup)</code> 和 <code>dispatch_group_leave(taskGroup)</code> 一定要成对，否则也会出现崩溃。大多数情况下我们都会注意，但是有时候可能会疏忽。例如多层 for loop 时 ：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDispatchGroup &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = <span class="string">@""</span>;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSArray</span> *folderList = [fileManager contentsOfDirectoryAtPath:path error:<span class="literal">nil</span>];</span><br><span class="line">    dispatch_group_t taskGroup = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *folderName <span class="keyword">in</span> folderList) &#123;</span><br><span class="line">        dispatch_group_enter(taskGroup);</span><br><span class="line">        <span class="built_in">NSString</span> *folderPath = [<span class="string">@"path"</span> stringByAppendingPathComponent:folderName];</span><br><span class="line">        <span class="built_in">NSArray</span> *fileList = [fileManager contentsOfDirectoryAtPath:folderPath error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileList) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">                <span class="comment">// 异步任务</span></span><br><span class="line">                dispatch_group_leave(taskGroup);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>dispatch_group_enter(taskGroup)</code> 在第一层 for loop 中，而 <code>dispatch_group_leave(taskGroup)</code> 在第二层 for loop 中，两者的关系是一对多，很容造成崩溃。有时候嵌套层级太多，很容易忽略这个问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于 iOS 并发编程，就总结到这里。后面如果有一些 best practices 我会更新进来。另外，因为文章比较长，可能会出现一个错误，欢迎指正，我会对此加以修改。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://bestswifter.com/ios-lock/" target="_blank" rel="noopener">深入理解 iOS 开发中的锁</a></li>
<li><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></li>
<li><a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">深入理解 GCD</a></li>
<li><a href="http://blog.jimmyis.in/dispatch_once/" target="_blank" rel="noopener">GCD源码分析2 —— dispatch_once篇</a></li>
<li><a href="http://lingyuncxb.com/2018/02/10/GCD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%906%20%E2%80%94%E2%80%94%20dispatch-source%E7%AF%87/" target="_blank" rel="noopener">GCD源码分析6 —— dispatch_source篇</a></li>
<li><a href="https://developer.apple.com/documentation/dispatch?language=objc" target="_blank" rel="noopener">Dispatch</a></li>
<li><a href="https://developer.apple.com/documentation/foundation/task_management?language=objc" target="_blank" rel="noopener">Task Management - Operation</a></li>
<li><a href="https://github.com/apple/swift-corelibs-foundation/tree/master/Foundation" target="_blank" rel="noopener">swift-corelibs-foundation</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/226/" target="_blank" rel="noopener">Advanced NSOperations</a></li>
</ol>
<div align="center"><br><img src="/uploads/Reward.png" width="248" height="256"><br></div>

</div></article></div></main><footer><div class="paginator"><a href="/2018/04/07/iOS-AutoLayout-Understanding/" class="prev">上一篇</a><a href="/2018/03/25/iOS-Event-Response/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Fri Apr 06 2018 23:04:23 GMT+0800',
    owner: 'boolchow',
    repo: 'boolchow.github.io',
    oauth: {
        client_id: '06247ad6645fcdc4c37c',
        client_secret: 'b3107efca11a366f4da8281d78bf59880f19a253',
    },
})
gitment.render('container')</script><div class="copyright"><p>版权声明 : 本博客为博主原创文章, 翻译文章, 未经允许不可用于商业用途.</p><p>公众号 : @bool周, 不定期更新文章.</p><p>© 2015 - 2018 boolchow | powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-120454091-1",'auto');ga('send','pageview');</script></body></html>