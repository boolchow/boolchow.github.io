<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 中的事件响应与处理 · Hexo</title><meta name="description" content="iOS 中的事件响应与处理 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/3290954642" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/boolchow" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 中的事件响应与处理</h1><div class="post-info">Mar 25, 2018</div><div class="post-content"><a id="more"></a>
<p>在使用 iPhone 过程中，会产生很多交互事件，例如点击、长按、摇晃、3D Touch 等。这些事件都需要 iOS 系统去响应并作出处理。这篇文章主要讲解一下系统如何去响应并处理这些事件。</p>
<h3 id="事件种类"><a href="#事件种类" class="headerlink" title="事件种类"></a>事件种类</h3><p>为满足用户需求，iOS 提供了多种事件，这里先说一下具体有哪些事件，现在脑中有一个清晰的轮廓。iOS 中的事件大致可以分为如下几类：</p>
<h4 id="1-触摸事件"><a href="#1-触摸事件" class="headerlink" title="1.触摸事件"></a>1.触摸事件</h4><p>触摸事件主要来源于人体触摸和通过 Apple Pencil (iPad) 触摸。触摸事件也分为以下几类：</p>
<ul>
<li>手势事件<ul>
<li>长按手势 (UILongPressGestureRecognizer)</li>
<li>拖动手势 (UIPanGestureRecognizer)</li>
<li>捏合手势 (UIPinchGestureRecognizer)</li>
<li>响应屏幕边缘手势 (UIScreenEdgePanGestureRecognizer)</li>
<li>轻扫手势 (UISwipeGestureRecognizer)</li>
<li>旋转手势 (UIRotationGestureRecognizer)</li>
<li>点击手势 (UITapGestureRecognizer)</li>
</ul>
</li>
<li>自定义手势</li>
<li>点击 button 相关</li>
</ul>
<h4 id="2-运动事件"><a href="#2-运动事件" class="headerlink" title="2.运动事件"></a>2.运动事件</h4><p>iPhone 内置陀螺仪、加速器和磁力仪，可以感知手机的运动情况。iOS 提供了 <a href="https://developer.apple.com/documentation/coremotion?language=objc" target="_blank" rel="noopener">Core Motion</a> 框架来处理这些运动事件。根据这些内置硬件，运动事件大致分为三类：</p>
<ul>
<li>陀螺仪相关：陀螺仪会测量设备绕 X-Y-Z 轴的自转速率，倾斜角度等。通过 <a href="https://developer.apple.com/documentation/coremotion?language=objc" target="_blank" rel="noopener">Core Motion</a> 提供的一些 API 可以获取到这些数据，并进行处理；通过系统可以通过内置陀螺仪获取设备的朝向，以此对 App UI 做出调整。</li>
<li>加速器相关：设备可以通过内置加速器测量设备在 X-Y-Z 轴速度的改变； <a href="https://developer.apple.com/documentation/coremotion?language=objc" target="_blank" rel="noopener">Core Motion</a> 提供了高度计（CMAltimeter）、计步器（CMPedometer） 等对象，来获取并处理这些产生的数据。</li>
<li>磁力仪相关：使用磁力仪可以获取当前设备的磁极、方向、经纬度等数据，这些数据多用于地图导航开发。</li>
</ul>
<h4 id="3-远程控制事件"><a href="#3-远程控制事件" class="headerlink" title="3.远程控制事件"></a>3.远程控制事件</h4><p>远程控制事件指通过耳机去控制手机上的一些操作。目前 iOS 仅提供我们远程控制音频和视频的权限。即对音频实现暂停/播放、上一曲/下一曲、快进/快退操作。可以在 <a href="https://developer.apple.com/documentation/uikit/uieventsubtype?language=objc" target="_blank" rel="noopener">UIEventSubtype</a> 中看到这些事件，一般用于开发播放器相关。</p>
<h4 id="4-按压事件"><a href="#4-按压事件" class="headerlink" title="4.按压事件"></a>4.按压事件</h4><p>iOS 9 提供了 3D Touch 事件，通过使用这个功能我们可以做如下操作：</p>
<ul>
<li>Quick Actions，重压 App icon 可以进行很多快捷操作。</li>
<li>Peek and Pop，使用这个功能对文件进行预览和其他操作，可以在手机自带 “信息” 里面试验。</li>
<li>Pressure Sensitivity，压力响应敏感，可以在备忘录中选择画笔，按压不同力度画出来的颜色深浅不一样。</li>
</ul>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>当 iPhone 接收到一个事件时，处理过程大体如下：</p>
<p><img src="/uploads/iOS-event-response/iOS 事件响应.png" alt="iOS 事件响应"></p>
<ol>
<li><p>当你通过一个动作（触摸/摇晃/线控）等触发一个事件，这时候会唤起处于休眠状态的 cup。</p>
</li>
<li><p>事件会通过使用 <code>IOKit.framework</code> 来封装成 <code>IOHIDEvent</code> 对象。</p>
<blockquote>
<p><code>IOKit.framework</code> 是一个系统框架的集合，用来驱动一些系统事件。<code>IOHIDEvent</code> 中的 HID 代表 <strong>Human Interface Device，即人机交互驱动</strong>。</p>
</blockquote>
</li>
<li><p>然后系统通过 mach port(IPC 进程间通信) 将 <code>IOHIDEvent</code> 对象转发给 SpringBoard.app。</p>
</li>
<li><p>SpringBoard.app 是 iOS 系统桌面 App，它只接收按键、触摸、加速、接近传感器等几种 Event。SpringBoard.app 会找到可以响应这个事件的 App，并通过 mach port(IPC 进程间通信) 将 <code>IOHIDEvent</code> 对象转发给这个 App。</p>
</li>
<li><p>前台 App 主线程 Runloop 接收到 SpringBoard.app 转发过来的消息之后，触发对应的 mach port 的 Source1 回调 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
</li>
<li><p>Source1 回调内部触发了 Source0 回调 <code>__UIApplicationHandleEventQueue()</code>。</p>
</li>
<li>Source0 回掉内部，将 <code>IOHIDEvent</code> 对象转化为 <code>UIEvent</code>。</li>
<li>Soucre0 回调内部调用 <code>UIApplication</code> 的 <code>+[sendEvent:]</code> 方法，将 <code>UIEvent</code> 传给<code>UIWindow</code>。</li>
</ol>
<p><code>UIWindow</code> 接收到这个事件后，开始传递事件，就是下一节要说的问题了。</p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p><code>UIWindow</code> 的收到的事件，有的是通过响应链传递，找到合适的 view 进行处理的；有的是不用传递，直接用 first responder 来处理的。这里先介绍使用响应链传递的过程，之后再说不通过响应链传递的一些事件。</p>
<p>事件传递大致可以分为三个阶段：Hit-Testing（寻找合适的 view）、Recognize Gesture（响应应手势）、Response Chain（touch 事件传递）。通过手去触摸屏幕所产生的事件，都是通过这三步去传递的，例如上文所说的<strong>触摸事件</strong>和<strong>按压事件</strong>。</p>
<h4 id="1-Hit-Testing"><a href="#1-Hit-Testing" class="headerlink" title="1. Hit-Testing"></a>1. Hit-Testing</h4><p><strong>这一过程主要来确定由哪个视图来首先处理 UITouch 事件</strong>。当你点击一个 view，事件传到 UIWindow 这一步之后，会去遍历 view 层级，直至找到那个合适的 view 来处理这个事件，这一过程也叫做 <code>Hit-Testing</code>。</p>
<h5 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h5><p>既然遍历，就会有一定的顺序。系统会根据添加 view 的前后顺序，确定 view 在 subviews 数组中的顺序。然后根据这个顺序将视图层级转化为图层树，针对这个树，使用<strong>倒着进行前序深度遍历</strong>的算法，进行遍历。</p>
<blockquote>
<p>如果使用 storyboard 添加视图，添加顺序等同于使用 addSubview() 的方式添加视图。即先拖入的属于 subviews 数组中第 0 个元素。</p>
</blockquote>
<p>例如下面一个图层，我点击了红色箭头标注的地方：</p>
<p><img src="/uploads/iOS-event-response/view层级图.png" alt="view层级图"></p>
<p>这个图层，转化为图层树如下，同时我也将遍历顺序标记出来了：</p>
<p><img src="/uploads/iOS-event-response/View 层级树状图.png" alt="view层级树状图"></p>
<p>在上面图层树中，View A,B,C 平级，以 A,B,C 先后顺序加入。所以当我点击一个 point 的时候，会从 View C 开始遍历；判断点不在 View C 上，转向 View B；判断点在 View B 上，转向右子树 View b2;判断点不在 View b2 上，转向 View b1; 点在 View b1 上，且其没有子视图，那么 View b1 为最合适的点。</p>
<blockquote>
<p>有时候你点击一次，会发现 <code>[hitTest:withEvent:]</code> 被调用了多次，我也不清楚为什么，但是这并不影响事件传递。可能你的手指点击时有轻微移动产生了多个事件。</p>
</blockquote>
<h5 id="hitTest-withEvent-方法实现原理"><a href="#hitTest-withEvent-方法实现原理" class="headerlink" title="[hitTest:withEvent:] 方法实现原理"></a>[hitTest:withEvent:] 方法实现原理</h5><p>UIWindow 拿到事件之后，会先将事件传递给图层树中距离最靠近 UIWindow 那一层最后一个 view，然后调用其 <code>[hitTest:withEvent:]</code>。注意这里是**先将视图传递给 view，再调用其 <code>[hitTest:withEvent:]</code> 方法。并遵循这样的原则：</p>
<ul>
<li>如果点不在这个视图内，则去遍历其他视图。</li>
<li>如果点击在这个视图内，但是其还有自视图，那么将事件传递给自视图，并且调用自视图的 <code>[hitTest:withEvent:]</code>.</li>
<li>如果点击在这个视图内，并且这个视图没有子视图，那么 return self，即它就是那个最合适的视图。</li>
<li>如果点击在这个视图内，并且这个视图没有子视图，但是不想作为处理事件的 view，可以 return nil，事件由父视图处理。</li>
</ul>
<p>有几种方式，设置了之后<strong>视图和其自视图</strong>不会再接收 touch 事件。分别为：</p>
<ul>
<li>视图被隐藏：self.hidden = YES.</li>
<li>视图不允许响应交互事件：self.userInteractionEnabled = NO.</li>
<li>视图的 alpha 在 0~0.01 之间。几乎透明。</li>
</ul>
<p>综上，我们可以得出 <code>[hitTest:withEvent:]</code> 方法实现大致如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 是否响应 touch 事件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isUserInteractionEnabled || <span class="keyword">self</span>.isHidden || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 点是否在 view 内</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> pointInside:point withEvent:event]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> [<span class="keyword">self</span>.subviews reverseObjectEnumerator]) &#123;</span><br><span class="line">        <span class="built_in">CGPoint</span> convertedPoint = [subview convertPoint:point fromView:<span class="keyword">self</span>];</span><br><span class="line">        <span class="comment">// point 进行坐标转化，递归调用，寻找自视图，直到返回 nil 或者 self</span></span><br><span class="line">        <span class="built_in">UIView</span> *hitTestView = [subview hitTest:convertedPoint withEvent:event];</span><br><span class="line">        <span class="keyword">if</span> (hitTestView) &#123;</span><br><span class="line">            <span class="keyword">return</span> hitTestView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重写-hitTest-withEvent"><a href="#重写-hitTest-withEvent" class="headerlink" title="重写 [hitTest:withEvent:]"></a>重写 [hitTest:withEvent:]</h5><h6 id="当你想中断传递时"><a href="#当你想中断传递时" class="headerlink" title="当你想中断传递时"></a>当你想中断传递时</h6><p>当时想在当前 view 处理事件，不想在对 subview 进行遍历，可以直接重写 <code>[hitTest:withEvent:]</code> 方法并 return self 即可。不过一般没有这样做的，这样会影响事件传递，产生一些 bug。</p>
<blockquote>
<p>因为遍历顺序在层级树中是从上向下，但是反应到视图上面，是从里向外传，所以这种情况也可以理解为 “透传”，即你点击了 View b2，但是最终响应的是 View B。</p>
</blockquote>
<h6 id="当你想增加视图的-touch-区域"><a href="#当你想增加视图的-touch-区域" class="headerlink" title="当你想增加视图的 touch 区域"></a>当你想增加视图的 touch 区域</h6><p>在实际开发中，有些 button 面积很小，不容易点击上。这时候你想扩大 touch 响应区域。可以通过重写 <code>[hitTest:withEvent:]</code> 方法实现。例如下图中的情况：</p>
<p><img src="/uploads/iOS-event-response/扩大touch区域.png" alt="扩大touch区域"></p>
<p>实现代码如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isUserInteractionEnabled || <span class="keyword">self</span>.isHidden || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> inset = <span class="number">45.0</span>f - <span class="number">78.0</span>f;</span><br><span class="line">    <span class="built_in">CGRect</span> touchRect = <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, inset, inset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(touchRect, point)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> [<span class="keyword">self</span>.subviews reverseObjectEnumerator]) &#123;</span><br><span class="line">            <span class="built_in">CGPoint</span> convertedPoint = [subview convertPoint:point fromView:<span class="keyword">self</span>];</span><br><span class="line">            <span class="built_in">UIView</span> *hitTestView = [subview hitTest:convertedPoint withEvent:event];</span><br><span class="line">            <span class="keyword">if</span> (hitTestView) &#123;</span><br><span class="line">                <span class="keyword">return</span> hitTestView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，你也可以通过<strong>重写父视图的 <code>[hitTest:withEvent:]</code> 方法实现</strong>。很多 App 都有这样的需求，例如自定义 UITabbar 时，中间的那个按钮一般比较大，超出了 UITabbar 高度，有时需要重写 <code>[hitTest:withEvent:]</code> 来处理响应范围。</p>
<h6 id="当你想指定某个-view-响应事件"><a href="#当你想指定某个-view-响应事件" class="headerlink" title="当你想指定某个 view 响应事件"></a>当你想指定某个 view 响应事件</h6><p>有时候在一个父视图中有多个子视图 A,B,C，无论点击 B 还是 C，你都想让 A 响应。例如 App Store 中的预览 App 页面就属于这种类型：</p>
<div align="center"><br><img src="/uploads/iOS-event-response/AppStore.PNG" width="375" height="670"><br></div>

<p>当你点击两侧边缘的时候，你想让中间的 UIScrollView 去响应，这时候可以通过重写 <code>[hitTest:withEvent:]</code> 方法实现。</p>
<p>转化为模型如下图：</p>
<p><img src="/uploads/iOS-event-response/ScorllView.png" alt="ScrollView"></p>
<p>当我点击边缘视图 B 和 C 时，我希望能够响应到 UIScrollView 上面，即可以正常滚动，这时候可以重写<strong>父视图</strong> 的 <code>[hitTest:withEvent:]</code>，指定响应 View。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *hitTestView = [<span class="keyword">super</span> hitTest:point withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (hitTestView) &#123;</span><br><span class="line">        hitTestView = <span class="keyword">self</span>.scrollView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitTestView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上即 Hit-Testing 过程相关知识，如果这一过程最终都没有找到合适的 View，那么本次事件将被丢弃。当你想改变遍历路径时，你可以考虑重写 <code>[hitTest:withEvent:]</code> 以达到你想要的结果。</p>
<h4 id="2-Gesture-Recognizer"><a href="#2-Gesture-Recognizer" class="headerlink" title="2. Gesture Recognizer"></a>2. Gesture Recognizer</h4><p>Gesture Recognizer（手势识别器）是系统封装的一些类，用来识别一系列的常见手势，例如点击、长按等。在上一步中确定了合适的 View 之后，<strong>UIWindow 会首先将 touches 事件先传递给 Gesture Recognizer，再传递给视图</strong>，这一点你可以通过自定义一个手势，并将手势添加到 View 上来验证。你会发现会先调用自定义手势中的一系列 touches 方法，再调用视图自己的一系列 touches 方法。</p>
<p>Gesture Recognizer 有一套自己的 touches 方法和状态转换机制。一个手势的响应到结束，流程如下：</p>
<p><img src="/uploads/iOS-event-response/Gesture_Recognizer状态转换.png" alt="Gesture_Recognizer状态转换"></p>
<p>系统为 Gesture Recognizer 提供了如下几种状态：</p>
<ul>
<li>UIGestureRecognizerStatePossible : 未确定状态。</li>
<li>UIGestureRecognizerStateBegan : 接收到 touches，手势开始。</li>
<li>UIGestureRecognizerStateChanged : 接收到 touches，手势改变。</li>
<li>UIGestureRecognizerStateEnded : 手势识别结束，在下个 run loop 前调用对应的 action 方法。</li>
<li>UIGestureRecognizerStateCancelled : 手势取消，恢复到 possible 状态。</li>
<li>UIGestureRecognizerStateFailed : 手势识别失败，恢复到 possible 状态。</li>
<li>UIGestureRecognizerStateRecognized : 等同于 UIGestureRecognizerStateEnded。</li>
</ul>
<p>当接收到一个系统定义的手势，首先会调用 recognizer 的 <code>[touchesBegan:withEvent:]</code> 方法，这时候 recognizer 的状态是未确定的；然后调用 <code>[touchesMoved:withEvent:]</code> 方法，依然没有识别成功；接下来要么调用 <code>[touchesEnded:withEvent:]</code> 方法，手势识别成功，调用对应的 action；要么调用 <code>[touchesCancelled:withEvent:]</code> 方法，手势识别失败。</p>
<p>官方也给出了一张比较明晰的图：</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/08b952fe-6f46-41eb-8b8a-4830c1d48842.png" alt=""></p>
<p>大致过程如此，但是细节上还有些不同。关于状态转换过程，官方给了几篇不错的文档：</p>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer/about_the_gesture_recognizer_state_machine" target="_blank" rel="noopener">About the Gesture Recognizer State Machine</a></li>
<li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer/implementing_a_discrete_gesture_recognizer" target="_blank" rel="noopener">Implementing a Discrete Gesture Recognizer</a></li>
<li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/implementing_a_custom_gesture_recognizer/implementing_a_continuous_gesture_recognizer" target="_blank" rel="noopener">Implementing a Continuous Gesture Recognizer</a></li>
</ul>
<h4 id="3-Response-Chain"><a href="#3-Response-Chain" class="headerlink" title="3. Response Chain"></a>3. Response Chain</h4><p>上面也涉及到了，对于 touch 事件，系统提供了四个方法来处理：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	iOS 9.1 增加的 API，当无法获取真实的 touches 时，UIKit 会提供一个预估值，并设置到 UITouch 对应的 estimatedProperties 中监测更新。当收到新的属性更新时，会通过调用此方法来传递这些更新值。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	eg: 当使用 Apple Pencil 靠近屏幕边缘时，传感器无法感应到准确的值，此时会获取一个预估值赋给 estimatedProperties 属性。不断去更新数据，直到获取到准确的值</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesEstimatedPropertiesUpdated:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_1);</span><br></pre></td></tr></table></figure>
<p>上面的前四个方法，是由系统自动调用的。</p>
<ul>
<li>默认情况下，当发生一个事件时，view 只接收到一个 <code>UITouch</code> 对象。当你使用多个手指<strong>同时</strong>触摸是，会接收多个 <code>UITouch</code> 对象，每个手指对应一个。多个手指分开触摸，会调用多次 touches 系列方法，每个 touches 里面有一个 <code>UITouch</code> 对象。</li>
<li>如果你想处理一些额外的事件，可以重写以上四个方法，处理你想要处理的事件。之后不要忘记调用 <code>[super touchexxxx]</code> 方法，否则事件处理就中断于此 view 了，不会传递上去了。</li>
</ul>
<p><code>UITouch</code> 对象保存了事件的相关信息：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span> timestamp; <span class="comment">///&lt; 事件产生或变化时间</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span> phase;       <span class="comment">///&lt; 所处阶段</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> tapCount;      <span class="comment">///&lt; 短时间内点击屏幕次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 点击类型，直接点击、间接点击还是笔触*/</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchType</span>         type <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 使用硬件设备点击时，以点为圆心的 touch 半径，以此确定 touch 范围大小 */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> majorRadius <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line"><span class="comment">/** 半径公差 */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> majorRadiusTolerance <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">UIWindow</span> *window; <span class="comment">///&lt; 事件所属 window</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">UIView</span> *view;     <span class="comment">///&lt; 事件所属 view</span></span><br><span class="line"><span class="comment">/** 所包含的手势识别器 */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">copy</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">UIGestureRecognizer</span> *&gt; *gestureRecognizers <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2);</span><br></pre></td></tr></table></figure>
<p>touch 事件处理的传递过程与 Hit-Testing 过程正好相反。Hit-Tesing 过程是从上向下（从父视图到子视图）遍历；touch 事件处理传递是从下向上（从子视图到父视图）传递。这也就是传说中的 <strong>Response Chain</strong>。最有机会处理事件的对象就是通过 Hit-Testing 找到的视图或者第一响应者，如果两者都能处理，则传递给下一个响应者，之后依次传递。官方给出了一个传递过程图，我就懒得画了：</p>
<p><img src="https://docs-assets.developer.apple.com/published/7c21d852b9/f17df5bc-d80b-4e17-81cf-4277b1e0f6e4.png" alt="Responder chains in an app"></p>
<blockquote>
<p>如果你不重写这几个 touches 方法，系统会通过响应链找到视图响应。如果你想做自己的事件处理操作，可以重写这几个方法。就是说，你不重写，事件处理正常传递；你重写了，处理完之后不要忘记调用 super 方法，使处理过程继续传递。</p>
</blockquote>
<h4 id="4-UIResponder"><a href="#4-UIResponder" class="headerlink" title="4.UIResponder"></a>4.UIResponder</h4><p>App 可以接收并处理很多事件，这过程中使用的是 <code>UIResponder</code> 对象来接收和处理的。<code>UIResponder</code> 类为那些需要响应比处理事件的对象定义了一组接口，使用这些接口可以处理各种花式事件。在 <code>UIKit</code> 中，<code>UIView</code>、<code>UIViewController</code> 和 <code>UIApplication</code> 这些类都是继承自 <code>UIResponder</code> 类。下面根据提供的这些接口，讲解一下这个类相关的东西。</p>
<h5 id="确定第一响应者"><a href="#确定第一响应者" class="headerlink" title="确定第一响应者"></a>确定第一响应者</h5><p>对于每个事件发生之后，系统会去找能给处理这个事件的第一响应者。根据不同的事件类型，第一响应者也不同：</p>
<ul>
<li>触摸事件：被触摸的那个 view。</li>
<li>按压事件：被聚焦按压的那个对象。</li>
<li>摇晃事件：用户或者 <code>UIKit</code> 指定的那个对象。</li>
<li>远程事件：用户或者 <code>UIKit</code> 指定的那个对象。</li>
<li>菜单编辑事件：用户或者 <code>UIKit</code> 指定的那个对象。</li>
</ul>
<blockquote>
<p>与加速计、陀螺仪、磁力仪相关的运动事件，是不遵循响应链机制传递的。Core Motion 会将事件直接传递给你所指定的第一响应者。更多信息可以查看 <a href="https://developer.apple.com/documentation/#//apple_ref/doc/uid/TP40007898-CH10-SW27" target="_blank" rel="noopener">Core Motion Framework</a>。</p>
</blockquote>
<p><code>UIResponder</code> 提供了几个方法（属性）来管理响应链 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#if UIKIT_DEFINE_AS_PROPERTIES</span><br><span class="line">@property(nonatomic, readonly, nullable) UIResponder *nextResponder;</span><br><span class="line">#else</span><br><span class="line">- (nullable UIResponder*)nextResponder;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if UIKIT_DEFINE_AS_PROPERTIES</span><br><span class="line">@property(nonatomic, readonly) BOOL canBecomeFirstResponder;    // default is NO</span><br><span class="line">#else</span><br><span class="line">- (BOOL)canBecomeFirstResponder;    // default is NO</span><br><span class="line">#endif</span><br><span class="line">- (BOOL)becomeFirstResponder;</span><br><span class="line"></span><br><span class="line">#if UIKIT_DEFINE_AS_PROPERTIES</span><br><span class="line">@property(nonatomic, readonly) BOOL canResignFirstResponder;    // default is YES</span><br><span class="line">#else</span><br><span class="line">- (BOOL)canResignFirstResponder;    // default is YES</span><br><span class="line">#endif</span><br><span class="line">- (BOOL)resignFirstResponder;</span><br><span class="line"></span><br><span class="line">#if UIKIT_DEFINE_AS_PROPERTIES</span><br><span class="line">@property(nonatomic, readonly) BOOL isFirstResponder;</span><br><span class="line">#else</span><br><span class="line">- (BOOL)isFirstResponder;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-[nextResponder]</code> 方法负责事件传递，默认返回 nil。子类必须实现此方法。例如 <code>UIView</code> 返回的是管理他的 <code>UIViewController</code> 对象或者其父视图；<code>UIViewController</code> 返回的是他的视图的父视图；<code>UIWindow</code> 返回的是 App 对象；<code>UIApplication</code> 返回的是 nil。这些在构建视图层次结构的时候就形成了。</li>
<li>使用 <code>-[isFirstResponder]</code> 来判断响应对象是否为第一响应者。</li>
<li>使用 <code>-[canBecomeFirstResponder]</code> 方法判断是否可以成为第一响应者。</li>
<li>使用 <code>-[becomeFirstResponder]</code> 方法将响应对象设置为第一响应者。</li>
</ul>
<p>对应的 <code>Resignxxxx</code> 系列方法使用场景类似。</p>
<h5 id="处理各种事件的方法"><a href="#处理各种事件的方法" class="headerlink" title="处理各种事件的方法"></a>处理各种事件的方法</h5><p><code>UIResponder</code> 定义了 touches 系列方法用来处理手势触摸事件；定义了 press 系列方法处理按压事件；定义了 motion 系列方法处理运动事件；定义了 remote 系列方法处理远程事件。可以说大部分事件都是通过这个类来处理的。这里就不详细说了。</p>
<h5 id="输入视图相关"><a href="#输入视图相关" class="headerlink" title="输入视图相关"></a>输入视图相关</h5><p>当我们使用 <code>UITextView</code> 或者 <code>UITextField</code> 时，点击视图会让其成为 fist responder，然后弹出一个视图（系统键盘 or 自定义键盘）让用户进行文本输入。在 <code>UIResponder + UIResponderInputViewAdditions</code> 这个分类中，定义了 <code>inputView</code> 和 <code>inputAccessoryView</code> 两个输入视图，样式分别如下：</p>
<p><img src="/uploads/iOS-event-response/inputView.png" alt="inputView"></p>
<p>设置了 <code>UITextView</code> 的 <code>inputView</code> 属性之后，将不再弹出键盘，弹出的是自定义的 view；设置了 <code>inputAccessoryView</code> 属性之后，将会在键盘上面显示一个自定义图，这个属性默认为 nil。</p>
<p>还有一些其他属性，与输入视图相关，这里不再详细说。</p>
<h5 id="复制粘贴相关"><a href="#复制粘贴相关" class="headerlink" title="复制粘贴相关"></a>复制粘贴相关</h5><p>在文本中选中一些文字后，会弹出一个编辑菜单，我们可以通过这些菜单进行复制、粘贴等操作。如下图是微信读书的自定义菜单：</p>
<p><img src="/uploads/iOS-event-response/复制粘贴菜单.png" alt="复制黏贴菜单"></p>
<p><code>UIResponder</code> 这个类中定义了 <code>UIResponderStandardEditActions</code> protocol，来处理复制粘贴相关事件。你可以通过重写 <code>UIResponder</code> 提供的 <code>-[canPerformAction:withSender]</code> 方法，判断 action 是否是你想要的，如果是的话，你便可以为所欲为：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:)) &#123;</span><br><span class="line">        <span class="comment">// 为你所欲为</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以重写 <code>UIResponder</code> 提供的 <code>-[targetForAction:withSender:]</code> 方法来处理某个 action 的接收者。和上面类似：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)targetForAction:(SEL)action withSender:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:)) &#123;</span><br><span class="line">        <span class="comment">// 为你所欲为</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> targetForAction:action withSender:sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="响应键盘快捷键"><a href="#响应键盘快捷键" class="headerlink" title="响应键盘快捷键"></a>响应键盘快捷键</h5><p>iOS 7 新增加了 <code>UIResponder + UIResponderKeyCommands</code> 分类，添加了一个 <code>keyCommands</code> 属性，同时还定义了 <code>UIKeyCommands</code> 类和一系列方法。使用这些方法，我们可以处理一些键盘快捷键。没用过，不多说，了解即可。</p>
<h5 id="支持-User-Activities"><a href="#支持-User-Activities" class="headerlink" title="支持 User Activities"></a>支持 User Activities</h5><p>iOS 8 Apple 提供了 Handoff 功能，通过这个功能，用户可以在多个 Apple 设备中共同处理一件事。例如我们使用 Mac 的 Safari 浏览一些东西，因为某些事情离开，这时候我们可以使用移动设备（iPad）上的的 Safari 继续浏览。</p>
<p>Handoff 的基本思想是用户在一个应用里所做的任何操作都可以看作是一个 Activity，一个 Activity 可以和一个特定 iCloud 用户的多台设备关联起来。设备和设备之间使用 Activity 传递信息，达到共享操作。</p>
<p>为了支持这个功能，iOS 8 后新增加了 <code>UIResponder + ActivityContinuation</code> 分类，提供了一些方法来处理这些事件。对于继承自 <code>UIResponder</code> 的对象，已经为我们提供了一个 <code>userActivity</code> 属性，多个响应者可以共享这个 <code>NSUserActivity</code> 类型的属性。另外我们可以使用 <code>-[updateUserActivityState:]</code> 方法来更新这个属性；使用 <code>-[restoreUserActivityState:]</code> 方法重置这个属性的状态。</p>
<p>更秀的操作，请看 <a href="http://www.cocoachina.com/ios/20150115/10926.html" target="_blank" rel="noopener">iOS 8 Handoff 开发指南</a>。</p>
<p>如你所见，<code>UIResponder</code> 类提供了处理大部分事件的接口，熟练了这些接口的使用，你便可以为所欲为。</p>
<h4 id="5-不遵循-Responder-Chain-的事件"><a href="#5-不遵循-Responder-Chain-的事件" class="headerlink" title="5.不遵循 Responder Chain 的事件"></a>5.不遵循 Responder Chain 的事件</h4><p>上面也说了，与加速计、陀螺仪、磁力仪相关的运动事件，是不遵循响应链机制传递的。而是直接传递给用户指定的 frist responder。所以要将运动事件传递给一个对象，需要遵循：</p>
<ul>
<li>对象的 <code>-[canBecomeFirstResponder]</code> 方法必须返回 YES。</li>
<li>在 view controller 控制器中，在合适的地方调用对象的 <code>-[becomeFirstResponder]</code> 和 <code>-[resignFirstResponder]</code> 方法。</li>
</ul>
<p>下面是一个处理摇一摇事件的例子：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义视图</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CustomShakeView</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Overrid Method</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (motion == <span class="built_in">UIEventSubtypeMotionShake</span>) &#123;</span><br><span class="line">    		<span class="built_in">CGFloat</span> width = <span class="keyword">self</span>.frame.size.width;</span><br><span class="line">    		<span class="built_in">CGFloat</span> height = <span class="keyword">self</span>.frame.size.height;</span><br><span class="line">        <span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height)];</span><br><span class="line">        label.text = <span class="string">@"phone was shaked"</span>;</span><br><span class="line">        label.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">        [<span class="keyword">self</span> addSubview:label];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// nothing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图控制器</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) CustomShakeView *shakeView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    <span class="keyword">self</span>.shakeView = [[CustomShakeView alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">250</span>, viewWidth, <span class="number">60</span>)];</span><br><span class="line">    <span class="keyword">self</span>.shakeView.backgroundColor = [<span class="built_in">UIColor</span> grayColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:_shakeView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    [<span class="keyword">self</span>.shakeView becomeFirstResponder];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    [<span class="keyword">self</span>.shakeView resignFirstResponder];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>远程控制事件与此类似，不在多说。</p>
<h3 id="各种事件的使用"><a href="#各种事件的使用" class="headerlink" title="各种事件的使用"></a>各种事件的使用</h3><p>这一章节主要是一些事件的使用 demo，基本 API 的调用，已经熟练使用的同学可以略过了。</p>
<h4 id="1-手势类使用"><a href="#1-手势类使用" class="headerlink" title="1.手势类使用"></a>1.手势类使用</h4><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建一个系统手势或者自定义手势，添加到一个 view 上即可。</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	<span class="built_in">UIView</span> *customView = [<span class="built_in">UIView</span> new];</span><br><span class="line">   	<span class="built_in">UITapGestureRecognizer</span> *gesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapAcation:)];</span><br><span class="line">   	[customView addGestureRecognizer:gesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tapAcation:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    <span class="comment">// 为所欲为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="2-touches-系列方法使用"><a href="#2-touches-系列方法使用" class="headerlink" title="2.touches 系列方法使用"></a>2.touches 系列方法使用</h4><p>这里是一个可以被拖动的 imageView 的例子。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DragView</span> : <span class="title">UIImageView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DragView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 获取前后两个点，计算偏移量，然后做平移转换</span></span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> currentPoint = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="built_in">CGPoint</span> previousPoint = [touch previousLocationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetX = currentPoint.x - previousPoint.x;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = currentPoint.y - previousPoint.y;</span><br><span class="line">    <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformTranslate</span>(<span class="keyword">self</span>.transform, offsetX, offsetY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    DragView *dragView = [[DragView alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line">    dragView.userInteractionEnabled = <span class="literal">YES</span>;</span><br><span class="line">    dragView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"picture.jpg"</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:dragView];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="3-摇一摇事件（运动事件）"><a href="#3-摇一摇事件（运动事件）" class="headerlink" title="3.摇一摇事件（运动事件）"></a>3.摇一摇事件（运动事件）</h4><p>请参见上一章的最后一小节。</p>
<h4 id="4-远程控制事件"><a href="#4-远程控制事件" class="headerlink" title="4.远程控制事件"></a>4.远程控制事件</h4><p>一个可以通过耳机控制音乐播放的 view controller，主要做的几件事情我已经用注释标出。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayVideoViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span>  isPlaying;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">AVAudioPlayer</span> *avAudioPlayer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PlayVideoViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Override Method</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接收线控事件，并设置 VC 为第一响应者</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] beginReceivingRemoteControlEvents];</span><br><span class="line">    [<span class="keyword">self</span> becomeFirstResponder];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取一个音频文件到 player 中</span></span><br><span class="line">    <span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"周杰伦-我的地盘"</span> ofType:<span class="string">@"mp3"</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:filePath];</span><br><span class="line">    <span class="keyword">self</span>.avAudioPlayer = [[<span class="built_in">AVAudioPlayer</span> alloc] initWithContentsOfURL:url error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="comment">// 取消接收线控事件</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] endReceivingRemoteControlEvents];</span><br><span class="line">    [<span class="keyword">self</span> resignFirstResponder];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 重写方法，返回 YES */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 实现这个方法，处理各种事件 */</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.subtype) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlTogglePlayPause</span>:</span><br><span class="line">            <span class="comment">// 同时控制播放和暂停</span></span><br><span class="line">            <span class="keyword">if</span> (!_isPlaying) &#123;</span><br><span class="line">                [_avAudioPlayer play];</span><br><span class="line">                _isPlaying = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [_avAudioPlayer pause];</span><br><span class="line">                _isPlaying = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</span><br><span class="line">            <span class="comment">// 播放</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>:</span><br><span class="line">            <span class="comment">// 暂停</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlStop</span>:</span><br><span class="line">            <span class="comment">// 停止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>:</span><br><span class="line">            <span class="comment">// 下一曲</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>:</span><br><span class="line">            <span class="comment">// 上一曲</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>初次建立这个工程，发现无论如何都不响应 <code>[remoteControlReceivedWithEvent:]</code> 方法，这时候你想工程中加入一段音频，并想办法使用代码播放一下这段音频（点击 button，调用 AVAudioPlayer 的 play) 方法，然后再重新编译应该就好了。属于玄学领域，我也不清楚为什么。</p>
</blockquote>
<h4 id="5-3D-Touch-事件"><a href="#5-3D-Touch-事件" class="headerlink" title="5.3D Touch 事件"></a>5.3D Touch 事件</h4><h5 id="Home-Screen-Quick-Actions"><a href="#Home-Screen-Quick-Actions" class="headerlink" title="Home Screen Quick Actions"></a>Home Screen Quick Actions</h5><p>使用这个功能，点击 icon 可以快速预览某些功能，并以此为入口点击进入。有两种方式来配置这个功能，一是直接使用 pilst 文件进行静态配置；另外一种是使用代码来动态配置。</p>
<h6 id="（1）使用-plist-文件配置"><a href="#（1）使用-plist-文件配置" class="headerlink" title="（1）使用 plist 文件配置"></a>（1）使用 plist 文件配置</h6><p>所有事件的数组叫做 UIApplicationShortcutItems，每个事件叫做 UIApplicationShortcutItem，每个 UIApplicationShortcutItem 中包含的信息如下：</p>
<blockquote>
<p>系统默认最多只能添加 4 个 item（不算“分享”这个 item），即使你添加了很多，最多也只显示四个。如果你想添加更多，可以效仿一下支付宝的做法，即在预览 view 中添加对应功能，这里就不贴图了。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Key</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr>
<td>UIApplicationShortcutItemType</td>
<td>事件的标识</td>
<td>YES</td>
</tr>
<tr>
<td>UIApplicationShortcutItemTitle</td>
<td>事件标题</td>
<td>YES</td>
</tr>
<tr>
<td>UIApplicationShortcutItemSubtitle</td>
<td>事件子标题</td>
<td>NO</td>
</tr>
<tr>
<td>UIApplicationShortcutItemIconType</td>
<td>系统定义的 icon 类型</td>
<td>NO</td>
</tr>
<tr>
<td>UIApplicationShortcutItemIconFile</td>
<td>icon 图片，以单一颜色，35*35 大小展示，如果设置了这个属性，UIApplicationShortcutItemIconType 属性将不起作用</td>
<td>NO</td>
</tr>
<tr>
<td>UIApplicationShortcutItemUserInfo</td>
<td>传递信息的 dictionary</td>
<td>NO</td>
</tr>
</tbody>
</table>
<p>你可以通过使用 plist 文件配置这些东西，例如下面这样：</p>
<p><img src="/uploads/iOS-event-response/plist 配置 3D Touch.png" alt="plist 配置 3D touch"></p>
<h6 id="2-使用代码动态配置"><a href="#2-使用代码动态配置" class="headerlink" title="(2) 使用代码动态配置"></a>(2) 使用代码动态配置</h6><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 item</span></span><br><span class="line">    <span class="built_in">UIApplicationShortcutIcon</span> *cameraIcon = [<span class="built_in">UIApplicationShortcutIcon</span> iconWithTemplateImageName:<span class="string">@"camera"</span>];</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIcon</span> *mosaicIcon = [<span class="built_in">UIApplicationShortcutIcon</span> iconWithTemplateImageName:<span class="string">@"mosaic"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIMutableApplicationShortcutItem</span> *cameraItem = [[<span class="built_in">UIMutableApplicationShortcutItem</span> alloc] initWithType:<span class="string">@"event://camera"</span> localizedTitle:<span class="string">@"Camera"</span> localizedSubtitle:<span class="literal">nil</span> icon:cameraIcon userInfo:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">UIMutableApplicationShortcutItem</span> *mosaicItem = [[<span class="built_in">UIMutableApplicationShortcutItem</span> alloc] initWithType:<span class="string">@"event://mosaic"</span> localizedTitle:<span class="string">@"Mosaic"</span> localizedSubtitle:<span class="literal">nil</span> icon:mosaicIcon userInfo:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放到应用中</span></span><br><span class="line">    [<span class="built_in">UIApplication</span> sharedApplication].shortcutItems = @[cameraItem,mosaicItem];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用上述任何一种方式添加了 item 之后，效果大概是这个样子：</p>
<p><img src="/uploads/iOS-event-response/3d_touch.PNG" alt="3dtouch"></p>
<h6 id="3-处理对应的事件"><a href="#3-处理对应的事件" class="headerlink" title="(3) 处理对应的事件"></a>(3) 处理对应的事件</h6><p>上述两种方式是配置事件入口，这里是响应对应事件。在 <code>AppDelegate</code> 中系统提供了一个代理方法：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))completionHandler &#123;</span><br><span class="line">    <span class="keyword">if</span> (shortcutItem) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([shortcutItem.type isEqualToString:<span class="string">@"event.responser.test://camera"</span>]) &#123;</span><br><span class="line">            <span class="comment">// 跳转到照相页面</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([shortcutItem.type isEqualToString:<span class="string">@"event.responser.test://mosaic"</span>]) &#123;</span><br><span class="line">            <span class="comment">// 跳转到马赛克页面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(<span class="literal">YES</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Peek-and-Pop"><a href="#Peek-and-Pop" class="headerlink" title="Peek and Pop"></a>Peek and Pop</h5><p>只需要两步，第一步是在当前的 View Controller 中实现 <code>UIViewControllerPreviewingDelegate</code> delegate；第二部是在预览 view controller 实现 <code>previewActionItems</code> delegate。具体代码如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 当前 View Controller */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TableViewController</span> () &lt;<span class="title">UIViewControllerPreviewingDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *dataArray;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TableViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.dataArray = @[<span class="string">@"依然范特西"</span>,<span class="string">@"十一月的肖邦"</span>,<span class="string">@"七里香"</span>,<span class="string">@"叶惠美"</span>,<span class="string">@"八度空间"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Table view data source</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"CellIdentifier"</span> forIndexPath:indexPath];</span><br><span class="line">    cell.textLabel.text = <span class="keyword">self</span>.dataArray[indexPath.row];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - UIViewControllerPreviewingDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** peek 操作，预览模式 */</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)previewingContext:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext viewControllerForLocation:(<span class="built_in">CGPoint</span>)location &#123;</span><br><span class="line">	 <span class="comment">// 这里没有使用 indexPath，实际项目中，需要根据 indexPath 选择对应的 VC</span></span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.tableView indexPathForCell:(<span class="built_in">UITableViewCell</span> *)[previewingContext sourceView]];</span><br><span class="line">    PreViewController *preViewController = [[<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>]</span><br><span class="line">                                            instantiateViewControllerWithIdentifier:<span class="string">@"PreViewController"</span>];</span><br><span class="line">    preViewController.preferredContentSize = <span class="built_in">CGSizeMake</span>(<span class="number">0.0</span>f, <span class="number">400.0</span>f);</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">375.0</span>f, <span class="number">40</span>);</span><br><span class="line">    previewingContext.sourceRect = rect;</span><br><span class="line">    <span class="keyword">return</span> preViewController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** pop 操作，继续按压 */</span></span><br><span class="line">- (<span class="keyword">void</span>)previewingContext:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext commitViewController:(<span class="built_in">UIViewController</span> *)viewControllerToCommit &#123;</span><br><span class="line">    PreViewController *preViewController = [[<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>]</span><br><span class="line">                                            instantiateViewControllerWithIdentifier:<span class="string">@"PreViewController"</span>];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:preViewController animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 预览 view controller */</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PreViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;<span class="built_in">UIPreviewActionItem</span>&gt;&gt; *)previewActionItems &#123;</span><br><span class="line">    <span class="built_in">UIPreviewAction</span> *shareAction = [<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"分享"</span> style:<span class="built_in">UIPreviewActionStyleDefault</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">        <span class="comment">// 分享</span></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIPreviewAction</span> *markAction = [<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"标记"</span> style:<span class="built_in">UIPreviewActionStyleDefault</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">        <span class="comment">// 标记</span></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> @[shareAction, markAction];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现之后效果大概是这个样子：</p>
<p><img src="/uploads/iOS-event-response/peek_and_pop.PNG" alt="peek_and_pop"></p>
<h5 id="Force-Properties"><a href="#Force-Properties" class="headerlink" title="Force Properties"></a>Force Properties</h5><p>3D Touch 所提供的最后一个功能，就是可以感应按压力度，转化到实际应用中，就是下面这张图：</p>
<div align="center"><br><img src="https://devimages-cdn.apple.com/ios/3d-touch/images/pressure-sensitivity_2x.jpg" width="375" height="670"><br></div>

<p>根据按压程度不同，颜色有深有浅。我们可以通过 <code>UITouch</code> 对象获取到这个值，使用这个值做一些其他操作：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *arrayTouch = [touches allObjects];</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = (<span class="built_in">UITouch</span> *)[arrayTouch lastObject];</span><br><span class="line">    <span class="built_in">CGFloat</span> force = touch.force;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"压力值为 %f"</span>,force);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-自定义手势"><a href="#6-自定义手势" class="headerlink" title="6.自定义手势"></a>6.自定义手势</h4><p>有些时候，系统提供的手势已经不能满足我们的需求了，这时候我们可以根据需要，自定义一个手势。自定义手势的一个思路就是：继承 <code>UIGestureRecognizer</code> 类，然后重写那几个 touches 方法，在里面处理手势识别器的状态，即从 began -&gt; end 的状态。</p>
<p>下面是效仿大神，写的一个“点击对角线两个点”才能响应的手势：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, TouchArea) &#123;</span><br><span class="line">    other = <span class="number">0</span>,</span><br><span class="line">    topLeft = <span class="number">1</span>,</span><br><span class="line">    topRight = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    bottomLeft = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    bottomRight = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    </span><br><span class="line">    bingoOne = topLeft | bottomRight,</span><br><span class="line">    bingoTwo = topRight | bottomLeft,</span><br><span class="line">    none = other,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TapDiagonalGesture</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) TouchArea alreadyTouched;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *trackingTouches;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> &lt;<span class="built_in">NSValue</span> *, <span class="built_in">NSNumber</span> *&gt; *allTouchedArea;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TapDiagonalGesture</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target action:(SEL)action &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithTarget:target action:action];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _trackingTouches = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">        _allTouchedArea = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UITouch</span> *touch <span class="keyword">in</span> touches) &#123;</span><br><span class="line">        TouchArea touchArea = [<span class="keyword">self</span> toucheAreaForPosition:[touch locationInView:<span class="keyword">self</span>.view] inView:<span class="keyword">self</span>.view];</span><br><span class="line">        <span class="keyword">if</span> (touchArea == other) &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateFailed</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.trackingTouches addObject:touch];</span><br><span class="line">        <span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithNonretainedObject:touch];</span><br><span class="line">        <span class="keyword">self</span>.allTouchedArea[value] = @(touchArea);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesMoved:touches withEvent:event];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UITouch</span> *touch <span class="keyword">in</span> touches) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![_trackingTouches containsObject:touch]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithNonretainedObject:touch];</span><br><span class="line">        TouchArea touchArea = <span class="keyword">self</span>.allTouchedArea[value].integerValue;</span><br><span class="line">        TouchArea currentArea = [<span class="keyword">self</span> toucheAreaForPosition:[touch locationInView:<span class="keyword">self</span>.view] inView:<span class="keyword">self</span>.view];</span><br><span class="line">        <span class="keyword">if</span> (currentArea == other || touchArea != currentArea) &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateFailed</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesEnded:touches withEvent:event];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UITouch</span> *touch <span class="keyword">in</span> touches) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![_trackingTouches containsObject:touch]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithNonretainedObject:touch];</span><br><span class="line">        TouchArea touchArea = <span class="keyword">self</span>.allTouchedArea[value].integerValue;</span><br><span class="line">        TouchArea currentArea = [<span class="keyword">self</span> toucheAreaForPosition:[touch locationInView:<span class="keyword">self</span>.view] inView:<span class="keyword">self</span>.view];</span><br><span class="line">        <span class="keyword">if</span> (currentArea == other || touchArea != currentArea) &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateFailed</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.trackingTouches removeObject:touch];</span><br><span class="line">        <span class="keyword">self</span>.allTouchedArea[value] = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.alreadyTouched |= currentArea;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.alreadyTouched == bingoOne ||</span><br><span class="line">            <span class="keyword">self</span>.alreadyTouched == bingoTwo) &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateRecognized</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesCancelled:touches withEvent:event];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UITouch</span> *touch <span class="keyword">in</span> touches) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![_trackingTouches containsObject:touch]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateCancelled</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    [<span class="keyword">super</span> reset];</span><br><span class="line">    [<span class="keyword">self</span>.trackingTouches removeAllObjects];</span><br><span class="line">    [<span class="keyword">self</span>.allTouchedArea removeAllObjects];</span><br><span class="line">    <span class="keyword">self</span>.alreadyTouched = none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldBeRequiredToFailByGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private Method</span></span><br><span class="line"></span><br><span class="line">- (TouchArea)toucheAreaForPosition:(<span class="built_in">CGPoint</span>)point inView:(<span class="built_in">UIView</span> *)view &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> origin = view.bounds.origin;</span><br><span class="line">    <span class="built_in">CGSize</span> size = view.frame.size;</span><br><span class="line">    <span class="keyword">int</span> horizontoalArea = [<span class="keyword">self</span> areaForValue:point.x rangeBegin:origin.x rangeLength:size.width];</span><br><span class="line">    <span class="keyword">int</span> verticalArea = [<span class="keyword">self</span> areaForValue:point.y rangeBegin:origin.y rangeLength:size.height];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (horizontoalArea == <span class="number">0</span> || verticalArea == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> other;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> shifts = (horizontoalArea &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) + (verticalArea &gt; <span class="number">0</span> ? <span class="number">2</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; shifts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)areaForValue:(<span class="built_in">CGFloat</span>)value</span><br><span class="line">         rangeBegin:(<span class="built_in">CGFloat</span>)rangeBegin</span><br><span class="line">        rangeLength:(<span class="built_in">CGFloat</span>)rangeLength &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> threadShold = MAX(<span class="number">40</span>, rangeLength / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (rangeLength &lt; threadShold * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value &lt;= rangeBegin + threadShold) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value &gt;= rangeBegin + rangeLength - threadShold) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在一个 view 上面添加这个手势之后，同时点击这个 view 对角线两个点（左上 &amp; 右下；左下 &amp; 右上），便会响应对应的 action。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面讲述了大部分事件以及其原理，了解了之后，对我们的开发很有帮助。当然，iOS 11 新增了 Drag and Drop 功能，这个功能大多在 Mac 或者 iPad 上面用，在 iPhone 上也可以使用，但使用的功能有限，这里就不多说了。</p>
<p>针对上面的内容，有问题可以提出，我会尽快修改。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures?language=objc" target="_blank" rel="noopener">Touches, Presses, and Gestures</a></li>
<li><a href="https://zhongwuzw.github.io/2016/09/12/iOS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B9%8BHit-Testing/" target="_blank" rel="noopener">iOS事件处理之Hit-Testing</a></li>
<li><a href="http://southpeak.github.io/2015/03/07/cocoa-uikit-uiresponder/" target="_blank" rel="noopener">UIKit: UIResponder</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/06/我所理解的 iOS 并发编程/" class="prev">PREV</a><a href="/2018/03/10/当你按下 ⌘ + R 后发生的事情/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>