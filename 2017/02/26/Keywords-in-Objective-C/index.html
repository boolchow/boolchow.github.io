<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 聊聊 Objective-C 中的一些关键字 · Hexo</title><meta name="description" content="聊聊 Objective-C 中的一些关键字 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/3290954642" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/boolchow" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">聊聊 Objective-C 中的一些关键字</h1><div class="post-info">Feb 26, 2017</div><div class="post-content"><a id="more"></a>
<p>在 OC 中，有很多常用的关键字。如何正确使用这些关键字，是学习一本语言的基础。通常面试官只需要问几<br>个关键字相关的问题，就能看出面试者的基础如何。例如 <code>#include、#import、@class的区别</code>，什么时候用 <code>const NSString *</code> 什么时候用 <code>NSString * const</code>，<code>define</code> 和 <code>static</code> 的正确使用等。不仅要知道怎么用，还要知道为什么这样用，不能只是“我看别人这么写”。</p>
<p>这篇文章将介绍一些关键字的使用及原理。</p>
<h3 id="static-amp-const-amp-extern"><a href="#static-amp-const-amp-extern" class="headerlink" title="static &amp; const &amp; extern"></a>static &amp; const &amp; extern</h3><p>将一些重复使用的字符串定义为<strong>字符串常量</strong>是一种良好的习惯，这样写起来代码便于维护。当然有时也会定义成<strong>宏</strong>，后面会解释两者区别。在定义常量时，通常会用 <code>static</code> 和 <code>extern</code> 来定义常量的<strong>作用域</strong>，用 <code>const</code> 来定义常量的<strong>可变性</strong>。</p>
<h4 id="1-static"><a href="#1-static" class="headerlink" title="1.static"></a>1.static</h4><p><code>static</code> 关键字，主要定义变量的<strong>作用域</strong>和<strong>生命周期</strong>。</p>
<p><code>static</code> 修饰局部变量，主要定义变量生命周期，静态局部变量，因为存储在全局数据区，不会像其他存储在栈区的局部变量一样随着函数体结束被释放。</p>
<p><code>static</code> 修饰全局变量，定义变量的作用域，被 <code>static</code> 修饰的量，只存储一份，始化一次，其他地方共享这一份数据。在 OC 中，<code>static</code> 变量声明一般在源文件（ “.m” ）中，如果放在头文件（ “.h” ）中，其他文件引入这个头文件时，容易引起命名冲突。被 <code>static</code> 修饰的全局变量，作用域为当前文件。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.申明在源文件中，声明在头文件中容易引起命名冲突</span></span><br><span class="line"><span class="comment">// 在类 TestClass 中</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *str = <span class="string">@"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类 OtherClass 中</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"TestClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *str = <span class="string">@"welcome!"</span>;    <span class="comment">// 编译不通过，这里会报 “Redefinition of 'str'” 重复定义的错误</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OtherClass</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">=======================================================</span><br><span class="line"><span class="comment">// 2.只存储一份，初始化一次，其他使用地方共享</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> numA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestViewcontroller</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			[<span class="keyword">self</span> addNum];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// numA = numC = 5; numB 一直为1，方法调用结束后被释放。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addNum &#123;</span><br><span class="line">	<span class="keyword">int</span> numB = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> numC = <span class="number">0</span>;</span><br><span class="line">	numA++;</span><br><span class="line">	numB++;</span><br><span class="line">	numC++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 如果一个变量在当前文件中被多处使用，建议使用 static 定义为当前类的全局变量</p>
</blockquote>
<h4 id="2-extern"><a href="#2-extern" class="headerlink" title="2.extern"></a>2.extern</h4><p><code>extern</code> 关键字，主要用来定义<strong>外部全局变量</strong>。前面说用 <code>static</code> 定义作用域为当前文件的全局变量。那如果想定义作用域为整个工程文件全局变量，即外部全局变量，则用 <code>extern</code>。</p>
<p>一般在头文件中使用 <code>extern</code> 声明变量，在源文件中赋值，尽量不要将外部全局变量的值暴露在头文件中；或者在头文件中声明，在其他文件中使用的时候再进行赋值。<code>extern</code> 关键字只对变量进行声明，表明该变量可能在本模块使用也可以在其他模块使用。例如类B如果想使用类A中定义的全局变量，只需要引入类A的头文件即可，这样即使在编译的时候找类B不到变量的定义也不会报错，它会在链接的时候在类A的目标代码中找到这个变量。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * notificationName;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestClass</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// TestClass.m 源文件中</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"TestClass.h"</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> * notificationName = <span class="string">@"notificationName"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>多说一点</strong><br>在 Apple API 中，我们可以看到一些与 <code>extern</code> 相关的宏定义，例如 <code>FOUNDATION_EXTERN</code> 、 <code>UIKIT_EXTERN</code>等。我们可以看一下其中一个的定义：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FOUNDATION_EXTERN 定义</span></span><br><span class="line"><span class="meta">#if defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#define FOUNDATION_EXTERN extern <span class="meta-string">"C"</span></span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define FOUNDATION_EXTERN extern</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AVKIT_EXTERN 定义</span></span><br><span class="line"><span class="meta">#ifdef __cplusplus</span></span><br><span class="line"><span class="meta">#define AVKIT_EXTERN	extern <span class="meta-string">"C"</span> __attribute__((visibility (<span class="meta-string">"default"</span>)))</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define AVKIT_EXTERN	extern __attribute__((visibility (<span class="meta-string">"default"</span>)))</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UIKIT_EXTERN 定义</span></span><br><span class="line"><span class="meta">#ifdef __cplusplus</span></span><br><span class="line"><span class="meta">#define UIKIT_EXTERN		extern <span class="meta-string">"C"</span> __attribute__((visibility (<span class="meta-string">"default"</span>)))</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define UIKIT_EXTERN	        extern __attribute__((visibility (<span class="meta-string">"default"</span>)))</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>OC 是支持与 C++ 混编的。<code>__cplusplus</code> 是 C++ 中自定义宏，上面这段宏表示如果这是一段 C++ 代码，则使用 <code>extern &quot;C&quot;</code>。那么问题来了，为什么要用 <code>extern &quot;C&quot;</code> 呢？在 C++ 中，是支持重载的。就是函数名可以一样，在编译处理时，会将“函数名及返回类型+参数及返回类型”合成一个字段，以此判断是哪个函数；但是 C 中是不支持重载的，编译时只会将函数名合成一个字段，即 C 和 C++ 对函数名的处理是不一样的。C++ 为了兼容 C，在C++代码中调用 C 编码的文件，就需要用 <code>extern&quot;C&quot;</code> 来告诉编译器:这是一个用 C 编码的文件，请用 C 的方式来链接它们。因此在进行 OC 与 C++ 混编时，用<code>FOUNDATION_EXTERN</code> 去修饰全局方法。</p>
<p>其他的例如 <code>UIKIT_EXTERN</code>、<code>AVKIT_EXTERN</code> 等与此类似，只是名字不同，目的是为了在不同的 framework 中使用时命名区分。平常定义一些外部全局变量时，直接使用 <code>extern</code> 即可。</p>
<h4 id="3-const"><a href="#3-const" class="headerlink" title="3.const"></a>3.const</h4><p><code>const</code>    关键字，多与 <code>static</code> 和 <code>extern</code> 连用，定义的类型为<strong>常类型</strong>，属性为 <strong>readonly</strong>。当初学习 C++ 时经常被这几个名词搞懵逼：常指针，指向常量的指针，指向常量的常指针。对应到 OC 上大同小异，请注意”异”在哪里。<code>const</code> 一般有两种用法：<br>（1）修饰基本变量，即 int、double、float 等类型<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两种写法是等价的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;		<span class="comment">// a 不可变</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a = <span class="number">10</span>;		<span class="comment">// a 不可变</span></span><br><span class="line">a = <span class="number">12</span>;	<span class="comment">// error</span></span><br></pre></td></tr></table></figure></p>
<p>(2) 修饰指针变量。在 OC 中，很多数据对象类型都有 <code>mutable（可变）</code> 和 <code>immutable（不可变）</code> 两种。<code>const</code> 在修饰”不可变”的指针变量时，多被用做定义”指针常量”。因为指针已经为不可变，再用 <code>const</code> 修饰没有意义。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 定义 "常量指针"，没有什么意义。'值'不可变的本身就不可变，可变的依然可变。</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *str1 = <span class="string">@"hello"</span>;   <span class="comment">// const 修饰不可变字符串，字符串本身就不可变。</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSMutableString</span> *str2 = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"you"</span>];   <span class="comment">// const 修饰可变字符串</span></span><br><span class="line">[str2 appendString:<span class="string">@"name"</span>];  <span class="comment">// str2 的值为@"you name"。str2 可以改变，const 没有起到作用。</span></span><br><span class="line"></span><br><span class="line">==================================================================================================</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 定义指针常量</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> str3 = <span class="string">@"const value"</span>;</span><br><span class="line">str3 = <span class="string">@"change point"</span>;	<span class="comment">// 此种操作不合法，str3 指向对象不能改变</span></span><br><span class="line"><span class="built_in">NSMutableString</span> * <span class="keyword">const</span> str4 = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"mutable value"</span>];</span><br><span class="line">str4 = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"change point"</span>];   <span class="comment">// 此种操作不合法，str4 指向对象不能改变</span></span><br><span class="line">[str4 appendString:<span class="string">@"change value"</span>];   <span class="comment">// str4 的值可以改变。所以 str4 的定义方式没有意义。</span></span><br></pre></td></tr></table></figure>
<p>综上，如果想定义不可变字符串（不可变数据对象），直接用 <code>NSString</code>；如果想定义可变字符串（可变数据对象），直接用 <code>NSMutableString</code>；如果想定义一个不可以改变的字符串（数据对象），即值不可变，指向对象也不可变，用 <code>NSString * const str = @&quot;xxx&quot;</code> 方式。且定义时就应赋值，如果不赋值，后面一直为 <code>nil</code>；如果想定义一个值可以改变，所指对象可以改变的字符串（数据对象），直接用 <code>NSString</code> 不就可以了么？</p>
<h4 id="4-const-与-static、extern-混用"><a href="#4-const-与-static、extern-混用" class="headerlink" title="4.const 与 static、extern 混用"></a>4.const 与 static、extern 混用</h4><p>如果需要在文件内部定义一个全局不可变常量，例如 <code>NSDictionary</code> 的”key”，可以这样定义：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .m 文件中</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span>  * <span class="keyword">const</span> kValueKey = <span class="string">@"key"</span>;   <span class="comment">// 如果变量只在当前文件使用，变量名前面加小写字母 'k'，习惯。</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要定义一个外部使用的全局不可变常量，例如 <code>NSNotification</code> 的”name”，可以这样定义：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> defineNotification;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m 文件中</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> defineNotification = <span class="string">@"defineNotification"</span>;</span><br></pre></td></tr></table></figure>
<p>如果只是单纯的定义通知名字，Apple 给提供了关键字 <code>NSNotificationName</code>。本质上没有什么区别，只不过命名习惯让人看起来舒服些。定义方式如下：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSNotificationName</span> <span class="keyword">const</span> defineNotification;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m 文件中</span></span><br><span class="line"><span class="built_in">NSNotificationName</span> <span class="keyword">const</span> defineNotification = <span class="string">@"defineNotification"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><p>宏定义（#define）从上古 C 系编程的时代就存在，一个好的宏定义，能够让代码看起来更简洁、优雅。宏定义主要分为<strong>对象宏</strong>和<strong>函数宏</strong>。宏定义在预编译阶段进行替换，不做类型检查。因此，宏定义的使用过程中有很多坑，尤其是在函数宏中。如果没有足够的功底，不要轻易写函数宏，否则会有惊喜。有关宏的深入了解，可以看一下喵神的<a href="https://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener">宏定义的黑魔法 - 宏菜鸟起飞手册</a>。希望你看完之后能够更优雅的使用宏，尤其是函数宏。</p>
<p>宏定义可以提升代码的优雅度，但也不能滥用。像上文中说的，一些”key”或者”notificationName”最好定义为静态常量。建议，将系统主题配置的数据定义为对象宏，例如主题色、字体大小、高度等，方便修改和使用；将常用并且冗长的 API 调用定义为函数宏，例如屏幕大小、系统版本判断等，用起来简洁、方便，减少大量冗余代码。还有很多使用场景，可以参考 Apple API，或者在平时敲码中进行积累。</p>
<p>最后，一个烂大街的问题就是：”#define 和 const”的区别。主要由以下几种区别：</p>
<ul>
<li><strong>编译处理过程的区别</strong><br>define宏在预处理阶段进行展开、替换，<strong>define宏没有类型</strong>，不做类型安全检查。宏定义是在预处理阶段进行替换，大量使用宏定义会造成编译时间过长。；const 常量在编译阶段使用，有具体类型，在编译阶段会进行类型检查。也就是说你用 define 定义一个字符串类型，然后赋值给一个浮点型变量，在编译阶段是不会报错的。但是现在的一些 IDE 都会有提示，例如 Xcode 就会提示对应错误。</li>
</ul>
<blockquote>
<p>编译四个大体步骤：预处理-&gt;编译-&gt;汇编-&gt;链接</p>
</blockquote>
<ul>
<li><strong>内存管理方式的区别</strong><br>正如很多文章里说的那样，宏定义不分配内存，变量定义分配内存。宏定义给出的是立即数，每有一次替换，变会分配一次内存，在内存中有若干个拷贝；const 常量给出的是内存地址，存储在全局静态区，只有一次拷贝，一份内存，效率要比宏定义高。</li>
</ul>
<p>这里有一个误区：这里说的”分配内存”是指在给变量或者常量赋值时，<strong>创建临时变量分配的内存</strong>。不是变量或者常量占用的内存。例如下面：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define MAX_COUNT 100			   // 宏常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CGFloat</span> height = <span class="number">20.5</span>f;   <span class="comment">// 定义时并未分配内存</span></span><br><span class="line"><span class="keyword">int</span> count1 = MAX_COUNT;         <span class="comment">// 编译期间进行替换，编译期间不进行内存分配。运行时为 count1 赋值时，需要创建 MAX_COUNT 临时变量，宏的多次分配内存，是为赋值时 MAX_COUNT 这个临时变量分配的内存。不是指的 count1 ，不要混淆。</span></span><br><span class="line"><span class="built_in">CGFolat</span> viewHeight = height;	   <span class="comment">// 此时为 const 常量 height 分配内存，此后不再分配。</span></span><br><span class="line"><span class="keyword">int</span> count2 = MAX_COUNT;	      <span class="comment">// 再次为创建 MAX_COUNT 临时变量分配内存。</span></span><br><span class="line"><span class="built_in">CGFloat</span> labelHeight = height;   <span class="comment">// 此时不再为 height 分配内存</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>修饰区别</strong><br>define宏可以定义常量，也可以定义方法；const只能用来定义常量，不能用来修饰方法。</li>
</ul>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define NSLogRect(rect) NSLog(@<span class="meta-string">"%s x:%.4f, y:%.4f, w:%.4f, h:%.4f"</span>, #rect, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)   // 喵神写的一个输出 rect 的函数宏</span></span><br><span class="line"><span class="meta">#define SCREEN_WITH	[[UIScreen mainScreen] bounds].size.width  // 屏幕高度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> key = <span class="string">@"key"</span>;    <span class="comment">// 只能定义常量，不能定义函数</span></span><br></pre></td></tr></table></figure>
<h3 id="id-amp-instancetype"><a href="#id-amp-instancetype" class="headerlink" title="id &amp; instancetype"></a>id &amp; instancetype</h3><p>id 被称为”万能指针”，可以指向任何对象，可以用于任何类型的对象。由 id 关键字定义的对象，在编译器看来只是一个对象指针，关于对象的信息，需要等到运行时才能确定。也就是说，id 定义的对象不做类型检查，向它发送未知的消息，编译阶段不会报错。id 在 OC 中如下定义：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if !OBJC_TYPES_DEFINED</span></span><br><span class="line"><span class="comment">/// Class 是一个 objc_class 结构体指针.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// objc_object 结构体,里面是一个 Class 类型成员.</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// id 为一个 objc_object 结构体指针.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，id 本质是一个结构体指针，结构体中只有一个成员 <code>isa</code>。任何一个 OC 对象，都会带一个默认的 <code>isa</code> 指针来存储对象的具体类型和信息。</p>
<p>id 关键字主要有以下几个使用场景：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义 id 类型对象</span></span><br><span class="line"><span class="keyword">id</span> newObj = [<span class="built_in">NSArray</span> array];   <span class="comment">// newObj 在运行时才确定指向对象类型为 NSArray,编译时不确定</span></span><br><span class="line">[newObj log];	                 <span class="comment">// NSArray 类中并没有 'log' 这个对象方法,但是编译时不报错,运行时报错.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义 delegate</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;MyDelegate&gt; delegate;   <span class="comment">// 不确定什么类型的对象作为代理,定义为 id 类型.并且规定实现 &lt;MyDelegate&gt; 这个协议的对象才能作为代理.因此像 delegate 发送消息时,首先要做 respondsToSelector:&lt;#(SEL)#&gt; 检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.作为返回类型</span></span><br><span class="line">- (<span class="keyword">id</span>)<span class="keyword">copy</span>;</span><br></pre></td></tr></table></figure>
<p>从 clang3.5 开始，出现类 <code>instancetype</code> 关键字。它可以表示一个方法的相关返回类型，与 <code>id</code> 不同的是，<code>instancetype</code> 返回是相关类的具体类型，编译器可以清楚的明确该类的信息，在调用该类的方法和属性时会进行检查。目前一般类的初始化方法，返回类型都为 <code>instancetype</code>。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSArray 的一些初始化方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)array;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)arrayWithObject:(ObjectType)anObject;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)arrayWithObjects:(<span class="keyword">const</span> ObjectType [])objects count:(<span class="built_in">NSUInteger</span>)cnt;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)arrayWithObjects:(ObjectType)firstObj, ... <span class="built_in">NS_REQUIRES_NIL_TERMINATION</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)arrayWithArray:(<span class="built_in">NSArray</span>&lt;ObjectType&gt; *)array;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjects:(ObjectType)firstObj, ... <span class="built_in">NS_REQUIRES_NIL_TERMINATION</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithArray:(<span class="built_in">NSArray</span>&lt;ObjectType&gt; *)array;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithArray:(<span class="built_in">NSArray</span>&lt;ObjectType&gt; *)array copyItems:(<span class="built_in">BOOL</span>)flag;</span><br></pre></td></tr></table></figure>
<h3 id="include-amp-import-amp-class-amp-import"><a href="#include-amp-import-amp-class-amp-import" class="headerlink" title="#include &amp; #import &amp; @class &amp; @import"></a>#include &amp; #import &amp; @class &amp; @import</h3><h4 id="1-include"><a href="#1-include" class="headerlink" title="1.#include"></a>1.#include</h4><p>在编译预处理阶段，预处理器会将一些引入的头文件替换成其对应的内容。例如，在源文件中引入了如下代码：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也引用了其他头文件，例如 <code>#import &lt;Foundation/NSArray.h&gt;</code>，则会按照同样的处理方式对引入的头文件进行逐级替代，依次递归下去。</p>
<p>在 C/C++ 中，我们用 <code>#include</code> 引入头文件，用 <code>#include &quot;&quot;</code> 引入自定义头文件，用 <code>#include &lt;&gt;</code> 引入系统头文件。使用双引号 <code>&quot;&quot;</code>，系统会优先从自定义头文件去查找，找不到再去系统头文件中找，如果还找不到，编译报错；使用尖括号 <code>&lt;&gt;</code>，系统会直接从系统头文件找，找不到会报错。如果直接用尖括号引入自定义头文件，则会直接报错。使用合理的方式去引入头文件，能够提高编译效率。</p>
<h4 id="2-import"><a href="#2-import" class="headerlink" title="2.#import"></a>2.#import</h4><p><code>#import</code> 可以说是 <code>#include</code> 的一个升级，有关 <code>&quot;&quot;</code> 和 <code>&lt;&gt;</code> 的使用与 <code>#include</code> 相同。除此之外，<code>#import</code> 解决了”重复引用“的问题。例如，A,B,C 三个文件，B 引用了 A，C 引用了 B 和 A，这时 C 相当于引用了两次 A。如果直接用 <code>#include</code> 编译会出问题，如果想使用 <code>#include</code> 应该这样写：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef(XXX)</span></span><br><span class="line">　　<span class="meta">#define XXX</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line"><span class="meta">#ifndef _AFNETWORKING_</span></span><br><span class="line">    <span class="meta">#define _AFNETWORKING_</span></span><br><span class="line">    <span class="meta">#import <span class="meta-string">"AFURLRequestSerialization.h"</span></span></span><br><span class="line">    <span class="meta">#import <span class="meta-string">"AFURLResponseSerialization.h"</span></span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>如果直接使用 <code>#import</code>，可以避免这个重复引用的问题。在编译的时候它会进行判断，如果已经引入了就不会再次引入。最好的习惯还是尽量不要在头文件(.h)中引入过多的文件，以免加长编译时间。另外，在引入系统文件或者 Pod 中的文件时，最好将包含头文件的外层文件夹一起引入。如果不引入，虽然编译能够通过，但是 Xcode 会提示一些错误，而且调用里面 API 时不会有代码提示。例如：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span>   // 前面添加 AVFoundation 文件夹</span></span><br></pre></td></tr></table></figure>
<h4 id="3-class"><a href="#3-class" class="headerlink" title="3.@class"></a>3.@class</h4><p><code>@class</code> 是告诉编译器有这样一个类，但是具体这个类里面有什么不知道。好比只给了你一本书的目录，但是没有给你书的内容。那么什么情况下使用 <code>@class</code> 呢？在编译预处理阶段，会将文件中的 .h 文件替换为对应的内容，如果 .h 文件中还引入了其他的 .h 文件，则进行逐级替换，依次递归。因此，<strong>尽量不要在 .h 文件中引入其他的 .h 文件</strong>。如果在声明一下方法或者属性时，需要用到某个类，这时可以用 <code>@class</code>，并且需要在 .m 文件中以 <code>#improt</code> 的方式再次引入这个文件。代码如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件中</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">UserModel</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewcontroller</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUserModel:(UserModel *)userModel;  <span class="comment">// 此处用到了 UserModel 定义参数类型</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m 文件中</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"UserModel.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> </span></span><br><span class="line"><span class="comment">// 在这里需要使用 UserModel 中的具体内容，此时需要以 #import 的方式引入。</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面说过，<code>@class</code> 只是告诉有这么一个类，如果使用类中的内容，则会出错。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestOne.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_EUMU</span>(<span class="built_in">NSInteger</span>, ReachabilityStatus) &#123;</span><br><span class="line">    ReachabilityStatusUnknown          = <span class="number">-1</span>,</span><br><span class="line">    ReachabilityStatusNotReachable     = <span class="number">0</span>,</span><br><span class="line">    ReachabilityStatusReachableViaWWAN = <span class="number">1</span>,</span><br><span class="line">    ReachabilityStatusReachableViaWiFi = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OtherClass.h</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">TestOne</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OtherClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)JudgeStatusWith:(ReachabilityStatus)status;   <span class="comment">// 这里使用 ReachabilityStatus 会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="4-import"><a href="#4-import" class="headerlink" title="4.@import"></a>4.@import</h4><p>在说和这个关键字之前，先说一下 <strong>Moudles</strong>。<code>#import</code> 相对于 <code>#include</code> 解决了重复引用的问题，但同时也带来另外一个问题：当引用关系很复杂时，编译时引用所占的代码量就会大幅上升。如果想解决这个问题，可以在项目文件中的 Supporting Files 组内的 .pch 文件中将经常引用的一些头文件添加进去，解决编译时间问题。默认情况下，里面会引入 <code>UIKit</code>，这是每个文件中经常引用到的文件。</p>
<p>但是并不能把所有的文件都放到 .pch 文件中，因为放入 .pch 中的头文件，每个文件都能访问，这样有些文件就能访问它本不应该访问的文件。</p>
<p>为了解决这个问题，Moudles 出现了。Modules 相当于将框架进行了封装，然后加入在实际编译之时加入了一个用来存放已编译添加过的 Modules 列表。如果在编译的文件中引用到某个 Modules 的话，将首先在这个列表内查找，找到的话说明已经被加载过则直接使用已有的；如果没有找到，则把引用的头文件编译后加入到这个表中。这样被引用到的 Modules 只会被编译一次，提升速度，从而解决了编译时间和访问混乱的问题。</p>
<p>Apple 在 LLVM5.0 引入了一个新的编译符号 <code>@import</code>，使用 @ 符号将告诉编译器去使用 Modules 的引用形式。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/FoundationErrors.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面等价于 #import &lt;UIKit/UIKit.h&gt;，同时还增加了 Moudles 的特性。</span></span><br><span class="line"><span class="keyword">@import</span> Foundation.FoundationErrors;</span><br></pre></td></tr></table></figure>
<h3 id="pragma"><a href="#pragma" class="headerlink" title="pragma"></a>pragma</h3><p><code>pragma</code> 是一个预处理指令，在 OC 中主要有两个作用：<strong>整理代码</strong> 和 <strong>防止警告</strong>。</p>
<ul>
<li><strong>整理代码</strong><br>代码是一种艺术，代码写的优雅整洁是艺术的提现。使用 <code>pragma</code> 能够是代码结构看起来更加整洁。具体语法为 <code>#pragma mark 描述内容</code>，或者 <code>#pragma mark - 描述内容</code>。</li>
</ul>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Lifecycle Method</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private Method</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupView &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - UIScrollViewDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在 Xcode 导航栏看起来效果如下：<br>（1）#pragma mark 描述内容<br>    <img src="/uploads/Keywords-in-Objective-C/pragma.png" alt="pragma 效果图"><br>（2）#pragma mark - 描述内容 （添加了 ‘-‘），代码块之间会有一条线，更加清晰。<br>    <img src="/uploads/Keywords-in-Objective-C/pragmaLine.png" alt="pragma 效果图"></p>
<ul>
<li><strong>防止警告</strong><br>比起代码结构乱七八糟，更让人崩溃的是，代码有一堆警告。编译器或者静态分析器会针对一些不合格的代码提示”警告”，目的是为了帮助开发者写出更加优秀的代码。在 Xcode 的 Build Settings 里面有关于 <code>warning</code> 提示的设定，如下图：<br><img src="/uploads/Keywords-in-Objective-C/warningSettings.png" alt="warning 设置"><br>其中三个设定都为 NO，<code>Inhibit All Warnings</code> 意为忽略所有警告，如果你想写出规范的代码，不要开启这个设定；<code>Pedantic Warnings</code> 开启之后，会更加严格检查代码的标准，如果使用系统不支持的一些扩展，会报 <code>Warning</code>；<code>Treat Warning as Error</code> 意为将 <code>warning</code> 作为 <code>error</code> 处理，也就是说，开启之后所有的 <code>Warning</code> 全部变为 <code>Error</code>，只要有警告则编译不通过。如果你要严格要求自己，那就开启吧…</li>
</ul>
<p>但是有时候代码必须要这样写，又不想看到 <code>Warning</code>，可以用预编译指令来处理。这时候可以使用 <code>#pragma</code>，代码如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZBWeakTimerTarget</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面方法中，屏蔽了 '-Warc-performSelector-leaks' 警告，如果不屏蔽，会报出警告 'PreformSelector may </span></span><br><span class="line"><span class="comment">// cause a leak because its selector is unknown'</span></span><br><span class="line">- (<span class="keyword">void</span>) fire:(<span class="built_in">NSTimer</span> *) timer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target) &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">        [<span class="keyword">self</span>.target performSelector:<span class="keyword">self</span>.selector withObject:timer.userInfo];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>如上述代码中，如果不用 <code>#pragma</code> 进行处理，会报有内存泄漏的警告。因为在 ARC 环境下调用方法时，Runtime 需要知道如何处理返回值。返回值会有 <code>void</code>、<code>int</code>、<code>char</code>、<code>NSString *</code>、<code>id</code>等类型，ARC 通常会根据你所在操作的对象的头文件进行处理，或忽略，或 retain 等。这个问题的具体解释可以去查看一下 stackoverflow 上面的前三个<a href="http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown/20058585#20058585" target="_blank" rel="noopener">高票回答</a>。在此主要阐明用 <code>#pragma</code> 可以消除这个 warning。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上只是对 OC 中部分常用关键字进行一下总结，在 OC 中还有很多关键字，在此就不进行一一分析了。关键字这个东西，用好了能够提高代码的效率和鲁棒性，乱用的话则会造成意想不到的结果。对于一些常用的关键字，建议了解其作用与原理后再去使用。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener">宏定义的黑魔法 - 宏菜鸟起飞手册</a></li>
<li><a href="http://nshipster.com/pragma/" target="_blank" rel="noopener">#pragma</a></li>
<li><a href="http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="noopener">performSelector may cause a leak because its selector is unknown</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/26/Clean-code/" class="prev">PREV</a><a href="/2017/01/25/annual-report-2016/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Sun Feb 26 2017 18:04:49 GMT+0800',
    owner: 'yangsoon',
    repo: 'yangsoon.github.io',
    oauth: {
        client_id: 'ed2bcac07bafa99f6a29',
        client_secret: '7afdc933c52026dcb33537ca63073c6e1530d318',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>