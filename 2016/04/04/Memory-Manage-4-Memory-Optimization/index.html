<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 内存管理之四：内存优化 · Hexo</title><meta name="description" content="iOS 内存管理之四：内存优化 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/3290954642" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/boolchow" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 内存管理之四：内存优化</h1><div class="post-info">Apr 4, 2016</div><div class="post-content"><a id="more"></a>
<p>所谓的内存优化，在设计程序的过程中，我们要在保证程序运行效率的前提下，尽量压缩程序运行时所占用的内<br>存。无论硬件设备的内存有多大，程序运行时占用内存越少越好。下面我将介绍在开发项目过程中，一些优化内存的方法。</p>
<h4 id="1-关于UITableView"><a href="#1-关于UITableView" class="headerlink" title="1.关于UITableView"></a>1.关于UITableView</h4><p>在项目开发中，<code>UITableView</code> 是用的比较多的一个视图控件。如果能够对 <code>UITableView</code> 的使用做好优化，程序的性能将提高很多。</p>
<h5 id="（1）善于使用UITableViewCell的重用机制"><a href="#（1）善于使用UITableViewCell的重用机制" class="headerlink" title="（1）善于使用UITableViewCell的重用机制"></a>（1）善于使用UITableViewCell的重用机制</h5><blockquote>
<p><strong>重用机制</strong>：这种机制下系统默认有一个可变数组 <code>NSMutableArray*  visiableCells</code>,用来保存当前显示的cell。一个可变字典 <code>NSMutableDictnery* reusableTableCells</code> ,用来保存可重复利用的cell。<code>UITableView</code> 只会创建一屏幕的cell，放在 <code>visiableCells</code>中。每当cell滑出屏幕，就会放到 <code>reusableTableCells</code> 中，当要显示某一个位置的cell时，先去 <code>reusableTableCells</code> 中取，如果有，直接取来用；如果没有，就会创建。这样极大减少了内存的开销。</p>
</blockquote>
<p>在iOS 6之后，在UITableView和UICollectionView中除了可以复用cell,还可以复用各个Section的Header和Footer。可见Apple一直在不断优化。在项目开发中，我们需要给 <code>UITableViewCells</code>、 <code>UICollectionViewCells</code>、<code>UITableViewHeaderFooterViews</code>设置正确的 <code>reuseIdentifier</code>。当有多类cell需要复用是，我们可以根据 <code>reuseIdentifier</code> 区分。我们可以在Xcode中设置，如下图：</p>
<p><img src="/uploads/Memory-Manage-4-Memory-Optimization/reuseIdentifier.png" alt="setReuseImg"></p>
<p>下面是一个简单的cell复用的示例:</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cellIdentifier = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    cellIdentifier = <span class="string">@"你的xib文件视图中标注的reuseIdentifier"</span>;</span><br><span class="line">    cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];    <span class="comment">//根据identifier复用cell</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没有对应的cell，创建cell</span></span><br><span class="line">    <span class="keyword">if</span>(!cell)&#123;</span><br><span class="line">        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:cellIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复用cell是一个很好的机制，但是使用不当也会出现问题，也就是所谓的<strong>复用重叠</strong>问题。看下面代码：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cellIdentifier = <span class="string">@"myCell1"</span>;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>;</span><br><span class="line">    cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:cellIdentifier];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((indexPath.row%<span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            cell.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cell.textLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>,(<span class="keyword">long</span>)indexPath.row];</span><br><span class="line">    <span class="comment">// Configure the cell...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我本打算将偶数行的设置为蓝色，基数行为默认颜色，并将cell的内容设置为行数，加以区分。结果如图：</p>
<p><img src="/uploads/Memory-Manage-4-Memory-Optimization/cell.png" alt="cell1Img"></p>
<p>从上图可以看出，开始初始化的13~14个cell正常，但是当滑动tableview时，就出现了问题，有的基数行cell也变为了蓝色。这是因为，下面的cell基本都是复用的，当没有显示指定cell的属性时，它就会使用已经创建过的cell的属性，导致有的蓝色有的白色。解决办法就是像下面这样写：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cellIdentifier = <span class="string">@"myCell1"</span>;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>;</span><br><span class="line">    cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:cellIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((indexPath.row%<span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            cell.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cell.textLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>,(<span class="keyword">long</span>)indexPath.row];</span><br><span class="line">    <span class="comment">// Configure the cell...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>切记：当对多种cell赋予属性时，一定不能写在 <code>if (!cell){}</code> 里面，避免复用出现问题。</p>
</blockquote>
<h5 id="（2）优化UITableViewCell高度计算"><a href="#（2）优化UITableViewCell高度计算" class="headerlink" title="（2）优化UITableViewCell高度计算"></a>（2）优化UITableViewCell高度计算</h5><p>UITableView有两个很重要的回调方法：<code>tableView:cellForRowAtIndexPath:</code>和<code>tableView:heightForRowAtIndexPath:</code>。很多人认为，在初始化tableview时，会先调用前者进行创建，然后再调用后者进行布局和属性设置。然而并非如此。真实的情况是这样的：UITableView是继承自UIScrollView的，需要先确定它的contentSize及每个Cell的位置，然后才会把重用的Cell放置到对应的位置。所以事实上，UITableView的回调顺序是先多次调用 <code>tableView:heightForRowAtIndexPath:</code> 以确定contentSize及Cell的位置，然后才会调用 <code>tableView:cellForRowAtIndexPath:</code>，从而来显示在当前屏幕的Cell。</p>
<p>举个例子：如果现在要显示20个Cell，当前屏幕显示5个。那么刷新（reload）UITableView时，UITableView会先调用20次 <code>tableView:heightForRowAtIndexPath:</code> 方法，然后调用5次<code>tableView:cellForRowAtIndexPath:</code>方法；滚动屏幕时，每当Cell滚入屏幕，都会调用一次<code>tableView:heightForRowAtIndexPath:</code>、<code>tableView:cellForRowAtIndexPath:</code>方法。</p>
<p>所以，对于UITableViewCell的高度计算的优化，就是对这两个函数的处理。至于如何优化<a href="http://weibo.com/u/1364395395?from=myfollow_all&amp;is_all=1" target="_blank" rel="noopener">@我就叫Sunny怎么了</a>写了一篇很好的<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">文章</a>去介绍。我就不多说了。</p>
<h5 id="（3）-懒加载（延迟加载）"><a href="#（3）-懒加载（延迟加载）" class="headerlink" title="（3） 懒加载（延迟加载）"></a>（3） 懒加载（延迟加载）</h5><p>懒加载并不是减少了程序内存消耗，而是将加载对象的时间推迟，在使用到对象的时候在对其进行初始化。例如一个UITableView一共有20行，但是屏幕只显示5行数组。那么在初始化tableview的时候，可以只先加载5行数据，另外15行等到显示的时候再去加载。这样可以减少初始化tableview时所需要的内存。（这样说有点牵强，因为实时加载会影响tableview的流畅度，但是大体就是这个意思 &gt;&lt;）</p>
<h4 id="2-关于图片的处理"><a href="#2-关于图片的处理" class="headerlink" title="2.关于图片的处理"></a>2.关于图片的处理</h4><p>图片在内存中会占很大开销，如果适当的处理图片，会减少很多内存的消耗。</p>
<h5 id="（1）缓存图片"><a href="#（1）缓存图片" class="headerlink" title="（1）缓存图片"></a>（1）缓存图片</h5><p>常见的从bundle中加载图片的方式有两种，一个是用<code>imageNamed</code>，二是用<code>imageWithContentsOfFile</code>，第一种比较常见一点。</p>
<p><code>imageNamed</code>的优点是当加载时会缓存图片。<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/index.html" target="_blank" rel="noopener"><code>imageNamed</code></a>的文档中这么说:<br>这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。</p>
<p>也就是说，<code>imageNamed</code>方法加载的图片，会对图片进行缓存。而 <code>imageWithContentsOfFile</code> 方法不会。</p>
<p>所以，如果要加载的图片比较小，而且会反复使用，这种情况选择用 <code>imageNamed</code>;如果要加载一个大图片，而且是一次性使用，那就使用 <code>imageWithContentsOfFile</code>，没必要浪费内存去缓存它。</p>
<p>代码示例：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对图片进行缓存</span></span><br><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"imgName"</span>]; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不对图片缓存，用完即释放</span></span><br><span class="line"> <span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWithContentsOfFile:<span class="string">@"imgName"</span>];</span><br></pre></td></tr></table></figure>
<h5 id="（2）调整图片大小"><a href="#（2）调整图片大小" class="headerlink" title="（2）调整图片大小"></a>（2）调整图片大小</h5><p>我们经常从网络获取图片或者从本地bundle获取图片，然后加载到 <code>UIImageView</code> 中。在加载图片时，应尽量保证图片大小和 <code>UIImageView</code> 大小相同。因为在运行中缩放图片很耗费资源，如果 <code>UIImageView</code> 嵌套在 <code>UIScrollView</code> 或者 <code>UITableView</code>中，会更耗费资源。</p>
<p>对于从本地bundle中加载的图片，我们可以事先件图片处理好。对于从网络下载的图片，在下载完成后，我们需要对图片进行缩放，然后再加载。</p>
<h5 id="（3）代码渲染-or-直接获取"><a href="#（3）代码渲染-or-直接获取" class="headerlink" title="（3）代码渲染 or 直接获取"></a>（3）代码渲染 or 直接获取</h5><p>前面已经说过，用代码去渲染一张图片会使图片占用内存翻倍。但是用代码去绘制图片，能够很好的去控制图片，并且能够做出很多漂亮的效果，前提是牺牲一部分内存；那如果所有图片都从bundle中加载呢？那会使bundle的体积增大，同时不能够用代码去灵活处理图片的效果。<br>所以，在开发过程中，是代码渲染图片，还是从bundle获取图片，需要做一个权衡。</p>
<h4 id="3-数据处理"><a href="#3-数据处理" class="headerlink" title="3.数据处理"></a>3.数据处理</h4><p>在项目开发中，我们会使用到各种格式的数据，例如 <code>JSON</code>、<code>XML</code> 等。还有各种各样的数据结构，例如数组、链表、字典、集合等。使用正确的数据格式和使用正确的数据结构，会减少我们的资源消耗。</p>
<h5 id="（1）选择正确的数据格式"><a href="#（1）选择正确的数据格式" class="headerlink" title="（1）选择正确的数据格式"></a>（1）选择正确的数据格式</h5><p>App与网络进行交互时，常常采用 <code>JSON</code> 或者 <code>XML</code> 类型的数据格式。</p>
<p><code>JSON</code> 是一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。解析 <code>JSON</code> 会比 <code>XML</code> 更快，但是 <code>JSON</code> 传输的数据比较小。</p>
<p><code>XML</code> 是一种重量级的数据交换格式，适用于很大的数据传输。当数据量较大时，使用 <code>XML</code> 数据格式，会极大减少内存消耗，增加性能。</p>
<p>另外，尽量避免数据多次转化。例如tableview中需要以数组的形势去赋值。那么服务器尽量返回数组类型。如果返回 <code>JSON</code> 类型，在去转换为 <code>NSArray</code> 类型，也会增加开销。</p>
<h5 id="（2）选择正确的数据结构"><a href="#（2）选择正确的数据结构" class="headerlink" title="（2）选择正确的数据结构"></a>（2）选择正确的数据结构</h5><p>不同的数据结构，处理数据的速度是不同的。</p>
<ul>
<li><strong>数组</strong> NSArray NSMutableArray:有序的一组值。使用索引来查询很快，使用值查找很慢， 插入/删除很慢。</li>
<li><strong>字典</strong>  NSDictionary NSMutableDictionary:存储键值对。用键来查找比较快。</li>
<li><strong>集合</strong> NSSet NSMutableSet:无序的一组值。用值来查找很快，插入/删除很快。</li>
</ul>
<h4 id="4-View的处理"><a href="#4-View的处理" class="headerlink" title="4.View的处理"></a>4.View的处理</h4><h5 id="（1）避免使用过于复杂的xib"><a href="#（1）避免使用过于复杂的xib" class="headerlink" title="（1）避免使用过于复杂的xib"></a>（1）避免使用过于复杂的xib</h5><p>在目前很多项目开发中，还经常用到 <code>xib</code>。当加载一个 <code>xib</code> 时，所有的内容都会放到内存里，包括任何图片。如果 <code>xib</code> 文件过于庞大，会占用很多内存。<code>xib</code> 与 <code>storyboard</code> 不同，<code>xib</code>即使暂时用不到，view也会存在于内存里；<code>storyboard</code> 仅在需要时实例化一个<code>view controller</code>。</p>
<p>而且设置view属性时，尽可能的<strong>把 <code>opaque</code> 属性设置为YES(不透明)</strong>。这样会提高渲染系统优化一些渲染过程和提高性能。</p>
<h5 id="（2）正确设置View的背景"><a href="#（2）正确设置View的背景" class="headerlink" title="（2）正确设置View的背景"></a>（2）正确设置View的背景</h5><p>设置UIView的背景图片主要有两种方式：</p>
<ul>
<li>使用 <code>UIColor</code>的 <code>colorWithPatternImage</code> 来设置背景色；</li>
<li>给 <code>UIView</code> 添加 <code>UIImageView</code> 子视图。</li>
</ul>
<p>第一种方式，适合使用小图平铺创建背景，能更快渲染也不会会费很多内存。例如使用一个10x10的像素大小重复背景。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"backgroundImg"</span>]];</span><br></pre></td></tr></table></figure>
<p>第二种方式，适合于使用大图，即整张图片来设置背景。如果使用 <code>colorWithPatternImage</code> 会消耗太多内存从而收到内存警告导致应用程序突然崩溃。而使用 <code>UIImageView</code> 会节约不少内存。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *backgroundView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"backgroundImg"</span>]];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:backgroundView];</span><br></pre></td></tr></table></figure>
<h5 id="（3）设定Shadow-Path"><a href="#（3）设定Shadow-Path" class="headerlink" title="（3）设定Shadow Path"></a>（3）设定Shadow Path</h5><p>如果用下面代码给 <code>view.layer</code> 添加一个shadow:</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Setup the shadow ...</span></span><br><span class="line">view.layer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">-1.0</span>f, <span class="number">1.0</span>f);</span><br><span class="line">view.layer.shadowRadius = <span class="number">5.0</span>f;</span><br><span class="line">view.layer.shadowOpacity = <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure>
<p>这会使<code>Core Animation</code> 不得不在后台得出图形并加好阴影之后再去渲染，这会开销很大。</p>
<p>如果使用shadowPath则会避免这种问题：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowPath = [[<span class="built_in">UIBezierPath</span> bezierPathWithRect:view.bounds] <span class="built_in">CGPath</span>];</span><br></pre></td></tr></table></figure>
<h4 id="5-合理使用Autorelease-Pool"><a href="#5-合理使用Autorelease-Pool" class="headerlink" title="5.合理使用Autorelease Pool"></a>5.合理使用Autorelease Pool</h4><p><code>NSAutoreleasePool</code>负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下也需要手动去创建它。</p>
<p>假如创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。</p>
<p>但是如果自己定义 <code>@autoreleasepool</code> ，在里面创建临时对象，可以避免这个问题：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        </span><br><span class="line"><span class="comment">/* Process the string, creating and autoreleasing more objects. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-正确处理缓存"><a href="#6-正确处理缓存" class="headerlink" title="6.正确处理缓存"></a>6.正确处理缓存</h4><p>缓存可以分为<strong>内存缓存</strong>和<strong>磁盘缓存</strong>。在项目开发过程中，我们经常会对一些图片、声音、数据进行缓存。合理利用缓存机制，会大大提高程序的性能，提高APP的流畅性。例如被广为使用的 <a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>,它使用的缓存机制是这样的：</p>
<p>（1）先根据查看内存缓存，如果有直接获取。</p>
<p>（2）如果内存没有，从磁盘缓存获取。</p>
<p>（3）如果磁盘缓存也没有，直接通过URL从网络下载。</p>
<p>当然这只是一个简单的描述，更加详细请看<a href="http://weibo.com/touristdiary?is_all=1" target="_blank" rel="noopener">@南峰子_老驴</a>的一篇<a href="http://southpeak.github.io/blog/2015/02/07/sourcecode-sdwebimage/" target="_blank" rel="noopener">SDWebImage实现分析</a>。</p>
<p>合理处理缓存，能够提高程序的性能，不用每次都从网络获取数据。但是也不能什么都存入缓存，这会消耗很多内存和磁盘空间。所以应合理使用缓存机制。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上，是我对于内存优化的一些理解。在写这篇文章过程中，参考了很多大牛的文章。对于一名在校应届本科生来说，我对于oc的理解还很浅薄，如果有错误或者有需要添加的地方，希望大家能够指出。我会加以改正并学习。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks" target="_blank" rel="noopener">25 iOS App Performance Tips &amp; Tricks</a></li>
<li><a href="http://longxdragon.github.io/2015/05/26/UITableView%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">UITableView优化技巧</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/10/Graduation/" class="prev">PREV</a><a href="/2016/03/30/Memory-Manage-3-ARC/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Mon Apr 04 2016 16:05:46 GMT+0800',
    owner: 'boolchow',
    repo: 'boolchow.github.io',
    oauth: {
        client_id: '488cd91b944b2a87ca89',
        client_secret: 'edb2d255469c1b1173b122caf28cbd472d35aa2e',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>