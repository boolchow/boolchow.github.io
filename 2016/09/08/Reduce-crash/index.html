<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 简单容错处理 · Hexo</title><meta name="description" content="iOS 简单容错处理 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/3290954642" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/boolchow" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 简单容错处理</h1><div class="post-info">Sep 8, 2016</div><div class="post-content"><a id="more"></a>
<p><strong>对</strong>一些代码进行容错处理，如果处理的好，会减少很多 crash。尤其对于像我这样的新手，稍不注意就会<br>写出几十个 bug。以下是针对刚入职这段时间所做项目的一个总结，同时提醒自己不要再犯同样的错误。</p>
<p>美好的一天，从没有 bug 开始~</p>
<hr>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>新手(像我这样)在使用一些常用的数据类型时，例如 <code>NSArray</code> 、<code>NSDictionary</code> 、<code>NSNumber</code> 、<code>NSString</code>等，经常会遇到一些崩溃问题。如果平时写程序首先进行容错判断，会减少很多崩溃问题。下面列举一些新手需要注意的情况。</p>
<h5 id="1-NSArray-amp-NSMutableArray"><a href="#1-NSArray-amp-NSMutableArray" class="headerlink" title="1.NSArray &amp; NSMutableArray"></a>1.NSArray &amp; NSMutableArray</h5><ul>
<li>+(instancetype)arrayWithObject:(ObjectType)anObject;</li>
</ul>
<p>提前判断对象是否为 nil，传入 nil 会引起崩溃</p>
<ul>
<li>-(ObjectType)objectAtIndex:(NSUInteger)index;</li>
</ul>
<p>提前判断 index 是否小于数组个数，否则会因数组越界引起崩溃</p>
<ul>
<li>-(NSArray<objecttype> *)arrayByAddingObject:(ObjectType)anObject;</objecttype></li>
</ul>
<p>提前判断传入的对象是否为 nil，传入 nil 会引起崩溃</p>
<ul>
<li>-(void)addObject:(ObjectType)anObject;</li>
</ul>
<p>提前判断传入的对象是否为 nil，传入 nil 会引起崩溃</p>
<ul>
<li>-(void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;</li>
</ul>
<p>提前对 anyObject 进行非空判断 &amp;&amp; 对 index 进行越界判断，否则可能引起崩溃</p>
<ul>
<li>-(void)removeObjectAtIndex:(NSUInteger)index;</li>
</ul>
<p>提前对 index 进行越界判断，否则可能会因数组越界引起崩溃</p>
<ul>
<li>-(void)replaceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;</li>
</ul>
<p>提亲对 index进行越界判断 &amp;&amp; 对 anyObject 进行非空判断，否则可能引起崩溃</p>
<h5 id="2-NSDictionary-amp-NSMutableDictionary"><a href="#2-NSDictionary-amp-NSMutableDictionary" class="headerlink" title="2.NSDictionary &amp; NSMutableDictionary"></a>2.NSDictionary &amp; NSMutableDictionary</h5><ul>
<li>+(instancetype)dictionaryWithObject:(ObjectType)object forKey:(KeyType <nscopying>)key;</nscopying></li>
</ul>
<p>提前判断 object 和 key 是否为 nil，如有一个为 nil 则会崩溃</p>
<ul>
<li>-(nullable id)objectForKey:(NSString *)anAttribute;</li>
</ul>
<p>提前判断传入参数是否为 nil，传入 nil 会引起崩溃</p>
<ul>
<li>-(void)setObject:(ObjectType)anObject forKey:(KeyType <nscopying>)aKey;</nscopying></li>
</ul>
<p>提前判断 anyObject 和 aKey 是否为 nil，有一个为空都会崩溃</p>
<ul>
<li>-(void)removeObjectForKey:(KeyType)aKey;</li>
</ul>
<p>提前判断 akey 是否为 nil， 传入 nil 会引起崩溃</p>
<h5 id="3-NSNumber"><a href="#3-NSNumber" class="headerlink" title="3.NSNumber"></a>3.NSNumber</h5><p><code>NSNumber</code> 在进行类型转换时，需要先判断是否响应转换方法。在 <code>NSNumber</code> 的实例,可以转化为的类型有：</p>
<p><code>char、unsigned char、short、unsigned short、int、unsigned int、long、unsigned long、long long、unsigned long long、float、double、BOOL、NSInteger、NSUInteger</code> </p>
<p>例如下面这种情况，如果不提前进行判断，会引起崩溃：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)transType &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *testArray = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *testDict = @&#123;<span class="string">@"key"</span>:testArray&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNumber</span> *testNumber = (<span class="built_in">NSNumber</span> *) [testDict objectForKey:<span class="string">@"key"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> iValue = [testNumber intValue];     <span class="comment">// 程序会在此处崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们初始化 <code>NSNumber</code> 对象时，可能会使用一些意想不到的对象进行初始化。例如上面 <code>testNumer</code> 实际获得的是一个 <code>NSArray</code> 类型的对象，并不能响应 <code>intValue</code> 方法，因此正确的写法应为：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([testNumber respondsToSelector:<span class="keyword">@selector</span>(intValue)]) &#123;</span><br><span class="line">	<span class="keyword">int</span> iVaule = [testNumber intValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-NSString"><a href="#4-NSString" class="headerlink" title="4.NSString"></a>4.NSString</h5><p><code>NSString</code> 类使用时需要注意两点：</p>
<ul>
<li><p>在使用一些字符串长度操作的方法，例如 <code>- (NSString *)stringByReplacingCharactersInRange:(NSRange)range withString:(NSString *)replacement</code> 时，需要判断传入的 <code>range</code> 是否越界。</p>
</li>
<li><p>在使用类似 <code>NSNumber</code> 的模糊类型转换方法时，首先进行 <code>respondsToSelector:</code> 判断。</p>
</li>
</ul>
<blockquote>
<p>以上实例方法的容错判断限于<strong>实例对象不为空</strong>的情况下，如果实例对象都为空了，即使传入空值也不会崩溃。</p>
</blockquote>
<h4 id="数据类型番外篇"><a href="#数据类型番外篇" class="headerlink" title="数据类型番外篇"></a>数据类型番外篇</h4><p>在项目开发过程中，很多数据都是依赖服务端返回。如果服务端不靠谱，你不知道服务端会返回给你什么乱七八糟的东西。在加上自己粗心忘记进行了 nil 判断，很容易造成崩溃。如果每次都去判断，会很麻烦，我们需要一个统一的方法进行非空判断。</p>
<p>你可能会想到 <code>Category</code> ，我开始也是想到使用 <code>Category</code> ，但是写到一半你会发现有很多问题。如果使用 <code>Category</code> 方式去重写 <code>objectAtIndex：</code> 方法，你可能无法处理通过下标[]访问数据的问题；另外 <code>NSArray</code> 是一个 <strong>类簇</strong> ，重写起来十分麻烦，工作量很大。</p>
<h5 id="类簇"><a href="#类簇" class="headerlink" title="类簇"></a>类簇</h5><blockquote>
<p>Class clusters are a design pattern that the Foundation framework makes extensive use of. Class clusters group a number of private concrete subclasses under a public abstract superclass. The grouping of classes in this way simplifies the publicly visible architecture of an object-oriented framework without reducing its functional richness. Class clusters are based on the Abstract Factory design pattern.</p>
</blockquote>
<p>简单说就是：类簇将一些私有的、具体的子类组合在一个公共的、抽象的超类下面，以这种方法来组织类可以简化一个面向对象框架的公开架构。这是一种基于 <code>工厂模式</code> 的实现。</p>
<p><code>NSArray</code> 、<code>NSDictionary</code> 、<code>NSNumber</code> 、 <code>NSString</code> 这些都是类簇。<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html" target="_blank" rel="noopener">官方文档</a> 通过 <code>NSNumber</code> 对类簇进行了解释。</p>
<p>针对 <code>NSArray</code> ，进行了如下测试：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)classClustersTest &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> iArray1 = [<span class="built_in">NSArray</span> alloc];</span><br><span class="line">    <span class="keyword">id</span> iArray2 = [iArray1 init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[iArray1 <span class="keyword">class</span>] description]); <span class="comment">// __NSPlaceholderArray</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[iArray2 <span class="keyword">class</span>] description]); <span class="comment">// __NSArray0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> mArray1 = [<span class="built_in">NSMutableArray</span> alloc];</span><br><span class="line">    <span class="keyword">id</span> mArray2 = [mArray1 init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[mArray1 <span class="keyword">class</span>] description]); <span class="comment">// __NSPlaceholderArray</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[[mArray2 <span class="keyword">class</span>] description]); <span class="comment">// __NSArrayM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，iArray1 与 mArray1 为同一个类，都为 <code>__NSPlaceholderArray</code>。但是 iArray2 为 <code>___NSArray0</code> (NSArray) ，mArray2 为 <code>__NSArrayM</code> (NSMutableArray) 类。因此对于类簇，在使用 <code>alloc + init</code> 方法进行初始化时，<code>alloc</code> 方法先生成一个中间类，在 <code>init</code> 方法时，生成对应的具体类型。具体在执行 <code>init</code> 方法时是如何区分 <code>immutable</code> 还是 <code>mutable</code> 未搞清楚。</p>
<h5 id="使用-Method-swizzling-进行方法交换"><a href="#使用-Method-swizzling-进行方法交换" class="headerlink" title="使用 Method swizzling 进行方法交换"></a>使用 Method swizzling 进行方法交换</h5><p>上面说了，使用 <code>Category</code> 会很麻烦，而且移植性较差。因此想到了使用 <code>Method swizzling</code>。在使用 <code>Method swizzling</code> 时，有一步是根据 <code>类名</code> 和 <code>selector</code> 获取响应的方法，即使用 <code>class_getInstanceMethod(Class cls, SEL name)</code>。如果你像下面这样写，就会出现问题了：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getClassMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@"NSArray"</span>), <span class="keyword">@selector</span>(objectAtIndex:));</span><br><span class="line">        Method newMthod = class_getClassMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@"NSArray"</span>), <span class="keyword">@selector</span>(myMethod));</span><br><span class="line">        method_exchangeImplementations(originalMethod, newMethod);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到，<code>NSArray</code> 是类簇，是一个抽象类的集合。<code>objectAtIndex:</code> 真正所属的类应该是 <code>__NSArrayI</code>。因此，正确的写法应该这样：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SafeArray.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">SafeFunc</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">SafeFunc</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)safeObjectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="keyword">self</span>.count) &#123;</span><br><span class="line">        <span class="keyword">id</span> obj = [<span class="keyword">self</span> safetObjectAtIndex:index];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (obj == [<span class="built_in">NSNull</span> null]) &#123;	<span class="comment">// 为什么使用 [NSNull null]？</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SafeArray</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getClassMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@"NSArray"</span>), <span class="keyword">@selector</span>(objectAtIndex:));</span><br><span class="line">        Method newMthod = class_getClassMethod(<span class="built_in">NSClassFromString</span>(<span class="string">@"NSArray"</span>), <span class="keyword">@selector</span>(safeObjectAtIndex:));</span><br><span class="line">        method_exchangeImplementations(originalMethod, newMethod);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>NSArray 或者 NSDictionary 中不会有 nil 对象，但是可能会有 ‘空值’，因此使用 <code>obj == [NSNUll null]</code> ，如果使用 <code>obj == nil</code> 进行判断，那么这句话等于浪费。有关 <code>nil / Nil / NULL / NSNull</code>，请参考<a href="http://nshipster.com/nil/" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<p>对于 <code>NSNumber</code> 、 <code>NSDictionary</code> 这些有 immutable 和 mutable 类使用 <code>Method swizzling</code> 时都需要注意以上问题，找到真正的 <code>具体类</code> 进行操作。</p>
<h4 id="Delegate-使用"><a href="#Delegate-使用" class="headerlink" title="Delegate 使用"></a>Delegate 使用</h4><p>关于 <code>delegate</code> 的使用，需要注意三个问题：</p>
<h5 id="1-delegate-属性都要为-weak，不解释"><a href="#1-delegate-属性都要为-weak，不解释" class="headerlink" title="1.delegate 属性都要为 weak，不解释"></a>1.delegate 属性都要为 weak，不解释</h5><h5 id="2-‘委托方’调用代理方法时，需要通过-respondsToSelector-进行判断，否则代理对象没有实现这个方法，会导致崩溃"><a href="#2-‘委托方’调用代理方法时，需要通过-respondsToSelector-进行判断，否则代理对象没有实现这个方法，会导致崩溃" class="headerlink" title="2.‘委托方’调用代理方法时，需要通过 respondsToSelector: 进行判断，否则代理对象没有实现这个方法，会导致崩溃"></a>2.‘委托方’调用代理方法时，需要通过 <code>respondsToSelector:</code> 进行判断，否则代理对象没有实现这个方法，会导致崩溃</h5><h5 id="3-不要在单例中使用-delegate"><a href="#3-不要在单例中使用-delegate" class="headerlink" title="3.不要在单例中使用 delegate"></a>3.不要在单例中使用 delegate</h5><p>代理属性 <code>delegate</code> 是一个弱引用指针，指向的是<strong>代理对象</strong>的的内存地址。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZBDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;ZBDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)delegateTest &#123;</span><br><span class="line">    [<span class="keyword">self</span>.delegate doSomething];	<span class="comment">// self.delegate 指向 ClassB 的内存地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassB</span> : <span class="title">NSObject</span> &lt;<span class="title">ZBDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassB</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>如果在单例中使用 <code>delegate</code> ，因为单例对象使用都是一个对象，这样 <code>self.delegate</code> 就会不断被从新赋值，只保留最后一个，这样最终只有一个对象响应代理方法，其他对象都不会响应。</p>
<h4 id="NSnotification-使用"><a href="#NSnotification-使用" class="headerlink" title="NSnotification 使用"></a>NSnotification 使用</h4><p>关于 <code>NSnotification</code> 的使用，需要注意一下几个问题：</p>
<h5 id="1-注册问题"><a href="#1-注册问题" class="headerlink" title="1.注册问题"></a>1.注册问题</h5><p>如果一个对象注册了一个通知，然后又注册了一次，这两次不会合并，通知回调会被调用两次。因此在注册通知的时候，需要在 <code>init</code> 或者 <code>viewDidload</code> 这些一般整个生命周期只执行一次的方法里注册，不要在一些可重入的方法里面注册。<strong>避免重复注册问题。</strong></p>
<h5 id="2-发送通知"><a href="#2-发送通知" class="headerlink" title="2.发送通知"></a>2.发送通知</h5><p>建议所有的通知都要在 <strong>主线程</strong> 中发送，没有例外。如果在其他线程运行，需要发送通知时，回到主线程发送，否则注销通知时，因为发送通知和注销通知不在同一个线程，造成一些意想不到的结果(竞态条件)。</p>
<h5 id="3-注销通知"><a href="#3-注销通知" class="headerlink" title="3.注销通知"></a>3.注销通知</h5><p>如果在一个对象销毁时，不注销当前对象注册的通知，对象销毁后，再次向这个对象发送通知，会造成 crash。因此在类的 <code>dealloc</code> 方法中需要注销对象。</p>
<p>建议使用 <code>[[NSNotificationCenter defaultCenter] removeObserver:self];</code> 这种整体注销的方式，避免遗漏。</p>
<h4 id="NSTimer-使用"><a href="#NSTimer-使用" class="headerlink" title="NSTimer 使用"></a>NSTimer 使用</h4><p>使用 <code>NSTimer</code> 时需要注意 ‘repeat timer’ 的释放问题。如果你想在 <code>- (void)dealloc</code> 中执行 <code>[self.timer invalidate];</code>，一般情况下都是释放不了的。原因如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerTest</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerTest</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupTimer &#123;</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span>f</span><br><span class="line">                                                  target:<span class="keyword">self</span></span><br><span class="line">                                                selector:<span class="keyword">@selector</span>(doSomething)</span><br><span class="line">                                                userInfo:<span class="literal">nil</span></span><br><span class="line">                                                 repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>dealloc</code> 方法中，并不能将 timer 销毁，因为这个方法并不能执行。原因是：<code>Timer</code> 加到 <code>Runloop</code> 中，会被 <code>Runloop</code> 强引用，然后 <code>Timer</code> 对 <code>self</code> 有一个强引用，导致 <code>self</code> 不能够被释放，不能执行 <code>dealloc</code> 方法。</p>
<p><strong>要想销毁 <code>repeat</code> 类型的 <code>Timer</code>，必须要执行 <code>invalidate</code> 方法。</strong>可以去手动 （action）方式去调用，也可以在执行 <code>delloc</code> 之前去执行 <code>invalidate</code> 方法。如果想要在 <code>dealloc</code> 方法中去销毁，可以自己封装一个类，给 <code>Timer</code> 传一个假的 <code>target</code>，如下:</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MTBWeakTimerTarget</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL selector;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MTBWeakTimerTarget</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) fire:(<span class="built_in">NSTimer</span> *) timer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.target) &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">        [<span class="keyword">self</span>.target performSelector:<span class="keyword">self</span>.selector withObject:timer.userInfo];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MTBWeakTimer</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                                 target:(<span class="keyword">id</span>)aTarget</span><br><span class="line">                               selector:(SEL)aSelector</span><br><span class="line">                               userInfo:(<span class="keyword">id</span>)userInfo</span><br><span class="line">                                repeats:(<span class="built_in">BOOL</span>)repeats &#123;</span><br><span class="line">    MTBWeakTimerTarget *timerTarget = [MTBWeakTimerTarget new];</span><br><span class="line">    timerTarget.target = aTarget;</span><br><span class="line">    timerTarget.selector = aSelector;</span><br><span class="line">    timerTarget.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                                         target:timerTarget selector:<span class="keyword">@selector</span>(fire:) userInfo:userInfo</span><br><span class="line">                                                        repeats:repeats];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> timerTarget.timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.timer = [MTBWeakTimer scheduledTimerWithInterval:<span class="number">3.0</span></span><br><span class="line">                                               target:<span class="keyword">self</span></span><br><span class="line">                                             selector:<span class="keyword">@selector</span>(doSomething)</span><br><span class="line">                                             userInfo:<span class="literal">nil</span></span><br><span class="line">                                              repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>当然这个解决方案不是我想的，具体请看<a href="http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/" target="_blank" rel="noopener">作者原创</a>。</p>
<h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>在多线程环境中，因为线程安全问题引发的 crash 有很多，尤其是对一些数据类型进行操作时。有人可能认为使用 <code>immutable</code> 类型的就安全了，但是并不是你想象的那样。请看下面示例：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)threadSafe &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *dataArray = [<span class="built_in">NSArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// in thread one</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *otherArray = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>,@<span class="number">5</span>];  <span class="comment">// array count = 5</span></span><br><span class="line">        dataArray = [otherArray <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// in thread two</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *anotherArray = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>];  <span class="comment">// array count = 3</span></span><br><span class="line">        dataArray = [anotherArray <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// in main thread</span></span><br><span class="line">    <span class="keyword">int</span> a = dataArray[<span class="number">4</span>];   <span class="comment">// ????</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中可能会出现 crash。所以不要认为使用 <code>immutable</code> 类型的就线程安全了。处理线程安全问题，没有公式化的方法，不可能对所有用到的数据类型进行加锁，那样太损耗性能，只有对于一些特殊的数据对象，在读写时进行加锁。是否有必要加锁，写程序的时候还需要自己注意。</p>
<h5 id="关于-‘锁’-的一些问题"><a href="#关于-‘锁’-的一些问题" class="headerlink" title="关于 ‘锁’ 的一些问题"></a>关于 ‘锁’ 的一些问题</h5><p>今天写这个的时候，正好看到了<a href="http://m.weibo.cn/3321824014/4017336178496605?moduleID=feed&amp;uicode=10000002&amp;mid=4017421889132510&amp;luicode=10000011&amp;_status_id=4017336178496605&amp;lfid=2304133290954642_-_WEIBO_SECOND_PROFILE_WEIBO&amp;lcardid=" target="_blank" rel="noopener">南大</a>今天发的《iOS知识小集》，讲述了一下关于锁的问题。文中这样描述：</p>
<p>为了保证线程安全，可能会使用 <code>NSLock, @synchornized, pthread_mutex_t</code> 等方法，但是加锁和解锁是非常昂贵的操作，对性能会有影响。可以用GCD提供的信号量来进行优化。如下是使用 <code>锁</code> 和使用 <code>信号量</code> 处理相同数据所需时间的对比：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        [<span class="keyword">self</span> lockTime];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"========================================="</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        [<span class="keyword">self</span> semaphoreTime];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> subtractTimes(uint64_t endTime, uint64_t startTime) &#123;</span><br><span class="line">    </span><br><span class="line">    uint64_t difference = endTime - startTime;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> conversion = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(conversion == <span class="number">0.0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        mach_timebase_info_data_t info;</span><br><span class="line">        kern_return_t err = mach_timebase_info(&amp;info);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(err == <span class="number">0</span>)</span><br><span class="line">            conversion = <span class="number">1e-9</span> * (<span class="keyword">double</span>) info.numer / (<span class="keyword">double</span>) info.denom;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> conversion * (<span class="keyword">double</span>)difference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用锁</span></span><br><span class="line">- (<span class="keyword">void</span>)lockTime &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableSet</span> *items = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLock</span> *lock = [<span class="built_in">NSLock</span> new];</span><br><span class="line">    </span><br><span class="line">    uint64_t start = mach_absolute_time();</span><br><span class="line">    </span><br><span class="line">    dispatch_apply(<span class="number">50</span>, queue, ^(size_t inddex) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            [lock lock];</span><br><span class="line">            [items addObject:<span class="string">@"hi"</span>];</span><br><span class="line">            [lock unlock];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    uint64_t stop = mach_absolute_time();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"use lock time :%f"</span>, subtractTimes(stop, start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用信号量</span></span><br><span class="line">- (<span class="keyword">void</span>)semaphoreTime &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableSet</span> *items = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t itemLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    uint64_t start = mach_absolute_time();</span><br><span class="line">    </span><br><span class="line">    dispatch_apply(<span class="number">50</span>, queue, ^(size_t inddex) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            dispatch_semaphore_wait(itemLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            [items addObject:<span class="string">@"hi"</span>];</span><br><span class="line">            dispatch_semaphore_signal(itemLock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    uint64_t stop = mach_absolute_time();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"use semaphore time :%f"</span>, subtractTimes(stop, start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>程序运行结果如下图 (真机上测试运行) ：</p>
<p><img src="/uploads/Reduce-crash/锁与信号量对比输出.png" alt="锁与信号量对比输出"></p>
<p>从上面的 Log 中可以看出，使用 <code>锁</code> 和使用 <code>信号量</code> 处理相同的数据，时间不是一个量级的。因此，在做优化的时候，建议使用 <code>信号量</code> 来代替锁。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上是我作为一个 iOS 开发新手，在近期遇到的一些 crash 问题。对此做一个总结，以提醒自己今后不会再犯相同的错误。可能总结的有遗漏，或者有一些问题。如果有什么问题，还请大家指正。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="http://blog.sunnyxx.com/2014/12/18/class-cluster/" target="_blank" rel="noopener">1.从NSArray看类簇</a></p>
<p><a href="http://www.cocoachina.com/ios/20150925/13459.html" target="_blank" rel="noopener">2.打造Objective-C安全的Collection类型</a></p>
<p><a href="http://inessential.com/2015/05/21/how_not_to_crash_3_nsnotification" target="_blank" rel="noopener">3.How Not to Crash #3: NSNotification</a></p>
<p><a href="http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/" target="_blank" rel="noopener">4.iOS 中的 NSTimer</a></p>
<p><a href="http://m.weibo.cn/3321824014/4017336178496605?moduleID=feed&amp;uicode=10000002&amp;mid=4017421889132510&amp;luicode=10000011&amp;_status_id=4017336178496605&amp;lfid=2304133290954642_-_WEIBO_SECOND_PROFILE_WEIBO&amp;lcardid=" target="_blank" rel="noopener">5.南峰子-iOS知识小集</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/01/25/annual-report-2016/" class="prev">PREV</a><a href="/2016/07/10/Graduation/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>