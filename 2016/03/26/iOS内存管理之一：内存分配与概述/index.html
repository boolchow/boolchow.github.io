<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS内存管理之一：内存分配与概述 · Hexo</title><meta name="description" content="iOS内存管理之一：内存分配与概述 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/3290954642" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/boolchow" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS内存管理之一：内存分配与概述</h1><div class="post-info">Mar 26, 2016</div><div class="post-content"><a id="more"></a>
<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>在iOS系统中，程序运行时会将所需的<strong>数据</strong>、<strong>图片</strong>、<strong>文件</strong>等资源加载到内存。不同类型的数据资<br>源会加载到不同的内存分区，这些数据资源有的在程序运行时常驻内存，有的会在用完即释放掉。</p>
<p>常驻内存的数据资源所占内存我们暂命名为<strong>基础占用内存</strong>。当程序执行某个方法时，会在栈空间加载一些数据资源，这时占用内存会升高，函数执行完内存即释放掉。如果执行某个函数过程中加载资源过多，内存占用超出了系统限制，程序会被杀死。如果方法执行过程中对一些生成对象没有做好处理，则会出现<strong>内存泄露</strong>。</p>
<h3 id="二、内存分区"><a href="#二、内存分区" class="headerlink" title="二、内存分区"></a>二、内存分区</h3><p>下图是由C/C++/OBJC编译的程序占用内存分布的结构：<br><img src="http://cc.cocimg.com/api/uploads/20150109/1420794802937868.jpg" alt="Cache Separate"></p>
<p><strong>注</strong>：此处堆栈空间不是数据结构中的堆栈，两者没有关系，不要混淆。</p>
<h5 id="1-栈区-stack"><a href="#1-栈区-stack" class="headerlink" title="1.栈区 (stack)"></a>1.栈区 (stack)</h5><p>栈区由编译器在需要的时候自动分配，不需要的时候自动清除。栈中主要存放局部变量、函数传的参数等。栈是系统的数据结构，应唯一的进程/线程。</p>
<p>栈主要有<strong>静态分配</strong>和<strong>动态分配</strong>两种分配方式。无论是以哪种方式分配的空间，都无需手动管理释放。相比于堆，栈更加快速高效。</p>
<h5 id="2-堆区（heap"><a href="#2-堆区（heap" class="headerlink" title="2.堆区（heap)"></a>2.堆区（heap)</h5><p>堆区是由程序员分配和释放的，如果不去释放，在程序结束时候，系统可能会回收内存。但是编程人员应该养成良好习惯，时刻记得处理所分配的内存。在iOS中，使用alloc方式生成的对象都是存放在堆中。</p>
<p>堆区采用链表式管理，在分配内存时操作系统有一个记录空闲内存地址的链表，当接收到程序分配内存的申请时，操作系统就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后将该节点记录的内存地址分配给程序。不过容易产生内存碎片。</p>
<h5 id="3-全局区-静态区（static）"><a href="#3-全局区-静态区（static）" class="headerlink" title="3.全局区/静态区（static）"></a>3.全局区/静态区（static）</h5><p>全局区用来存放静态变量和全局变量，全局区又分为<strong>全局初始化区</strong>和<strong>全局未初始化区</strong>，用来存放已经初始化和未初始化的全局变量&amp;静态变量。程序结束后由系统释放。</p>
<h5 id="4-文字常量区"><a href="#4-文字常量区" class="headerlink" title="4.文字常量区"></a>4.文字常量区</h5><p>文字常量区用来存放常量字符串，程序调用结束后由系统释放。</p>
<h5 id="5-代码区"><a href="#5-代码区" class="headerlink" title="5.代码区"></a>5.代码区</h5><p>代码区用来存放函数体的二进制代码。</p>
<p>程序示例：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">int</span> a,<span class="keyword">char</span> b)		<span class="comment">//传入的a,b在栈区</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">10</span>;	<span class="comment">//栈区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;		<span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;	<span class="comment">//全局未初始化区</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i; 	<span class="comment">//栈区</span></span><br><span class="line">	<span class="keyword">char</span> *q;		<span class="comment">//栈区</span></span><br><span class="line">	<span class="keyword">char</span> *p2 = “name”;	<span class="comment">//“name"在常量区，*p2在栈区</span></span><br><span class="line">	<span class="keyword">char</span> *p3 = <span class="string">"name"</span>;	<span class="comment">//程序预处理时，会做优化，即在内存中只存取一个”name"字符串，p2,p3均指向它的地址。</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];		<span class="comment">//创建UIView对象所需的空间即堆空间。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、内存简单估算"><a href="#三、内存简单估算" class="headerlink" title="三、内存简单估算"></a>三、内存简单估算</h3><p>1.<strong>图片内存</strong>：在iOS系统中，一个APP运行时（一般占用几十兆内存），会加载APP的图标或者一些其他图片。这些图片在APP运行过程中个会一般会常驻内存，如果在程序运行过程中执行某个方法继续加载大量图片，这时内存占用急剧会上升。一般来说：</p>
<blockquote>
<p>图片占用内存大小 = 长 <em> 宽 </em> 4<br>一张512<em>512图片占用内存大小 = 521 </em> 512 * 4 = 1M</p>
</blockquote>
<p>在实际的项目开发中，我的加载的图标大小一般为几k或者几十k，可以接受</p>
<p>在iOS中，图片会被自动处理为2的N次方大小，所以<code>512 *1028</code>的图片和<code>1024*1024</code>的图片占用内存大小一样。如果图片由<code>[UIImage imageNamed:@&quot;imgName&quot;]</code>方法加载，则内存占用大小如上所述计算；如果图片由<code>CALayer</code>或者其他类绘制，则大小加倍，因为图片由系统渲染，需要额外消耗内存。</p>
<p>2.<strong>程序内存</strong>： 在程序启动后，每个函数的执行都要向系统索要资源，这个索要的资源即栈空间。函数执行的局部变量和参数均存放于此。以一个长度为10^5的字符串为例，简单的估算内存：</p>
<blockquote>
<p>char 类型占一个字节。<br>size = 10^5/1024 = 97k    //可以接受</p>
</blockquote>
<p>一般情况下，栈允许申请空间为2M。当函数执行所需空间大于2M时，系统会报<strong>栈溢出</strong>的异常。所以在写程序时，应尽量减少大量数据空间的开辟。</p>
<p>另外，很多函数的参数为指针。一个指针的大小与指针的数据类型无关，<strong>指针大小是由操作系统决定的</strong>（32位系统4个字节，64位系统8个字节），所以无论是一个<code>NString</code>类型的指针，还是一个<code>struct</code>指针，占用内存都一样，而且很小。当一个函数所传参数大小大于8个字节时，最好传指针，这样在函数运行时，会开辟少量栈空间，这也是为什么使用指针比较快的原因之一，因为它只传地址。</p>
<p>3.<strong>数据文件内存</strong>：与所加载的数据文件大小有关。</p>
<p>内存是系统的宝贵资源，无论是申请还是释放，都需要谨慎处理。在iOS系统中，一个APP一般情况下运行内存应小于<strong>70M</strong>。尽量避免大量动态开辟内存。例如你的程序正在使用40M内存，然后在执行方法时又动态申请了80M内存，那你的程序会立刻被系统kill。关于内存如何优化，后面会介绍几种方式。<br>欢迎大家对以上内容勘误。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://www.devtalking.com/articles/you-should-know-block/" target="_blank" rel="noopener">Objective-C中的Block</a><br>2.<a href="http://ksnowlv.blog.163.com/blog/static/218467056201452821224589/" target="_blank" rel="noopener">IOS UIImage关于内存占用的思考 </a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/03/29/Memory-Manage-2-MRC/" class="prev">上一篇</a><a href="/2016/03/25/题记—写在前面/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Sat Mar 26 2016 18:20:54 GMT+0800',
    owner: 'boolchow',
    repo: 'boolchow.github.io',
    oauth: {
        client_id: '488cd91b944b2a87ca89',
        client_secret: 'edb2d255469c1b1173b122caf28cbd472d35aa2e',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>