<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS内存管理之二：MRC(MannulReference Counting) · Hexo</title><meta name="description" content="iOS内存管理之二：MRC(MannulReference Counting) - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/3290954642" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/boolchow" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS内存管理之二：MRC(MannulReference Counting)</h1><div class="post-info">Mar 29, 2016</div><div class="post-content"><a id="more"></a>
<p>在<a href="http://luoanhao.github.io/2016/03/26/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E6%A6%82%E8%BF%B0/" target="_blank" rel="noopener">上一篇</a>文章中，介绍了内存的概述与iOS系统中内存<br>分布，让大家对内存的概念稍微有点“敏感”，虽然现在大部分iOS项目开发都是基于ARC的，但是对于MRC的理解也很重要。下面主要介绍基于MRC环境下的内存管理。</p>
<h3 id="一、引用计数"><a href="#一、引用计数" class="headerlink" title="一、引用计数"></a>一、引用计数</h3><p>iOS内存管理采用的引用计数器原理，那么什么是引用计数？原理是什么？为什么要使用引用计数？iOS大V<a href="http://weibo.com/tangqiaoboy?is_all=1" target="_blank" rel="noopener">@唐巧</a>在《iOS开发进阶》一书中做了介绍。我在这里简单描述一下。</p>
<h4 id="1-引用计数原理"><a href="#1-引用计数原理" class="headerlink" title="1.引用计数原理"></a>1.引用计数原理</h4><p>“引用计数器”可以简单理解为对象的一个标识属性，它标识着对象被多少个对象引用（持有）。当我们创建一个对象时，它的引用计数为1，当一个新的指针指向这个对象时，引用计数加1；当指针指针不再指向（持有）这个对象时，引用计数减1。当对象的引用计数为0时，说明这个对象不再被任何指针指向，这时就可以销毁对象，回收对象所占用的内存。    </p>
<p>引用计数原理图解如下：<br><img src="/uploads/Memory-Manage-2-MRC/Counter.png" alt="countImg"><br>当然，还有一种其他比较容易理解的解释场景：<a href="http://www.cocoachina.com/ios/20160219/15330.html" target="_blank" rel="noopener">员工在办公室使用灯的情景</a>，具体大家可以去这篇博文去看，在此不再阐述。</p>
<p>这样说或与有一些抽象，为了形象一下，下面用代码进行简单阐述：</p>
<p><strong>注</strong>：在运行这段程序时，我们需要手动关闭ARC，方法如图所示：<br><img src="/uploads/Memory-Manage-2-MRC/cancelARC.png" alt="CancelARC"></p>
<p>示例程序：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj1 = [[<span class="built_in">NSObject</span> alloc] init];		<span class="comment">//对像创建，引用计数=1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference count = %lu"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)[obj1 retainCount]);</span><br><span class="line">    <span class="built_in">NSObject</span> *obj2 = [obj1 <span class="keyword">retain</span>];	<span class="comment">//obj2持有对象，引用计数加1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference count = %lu"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)[obj1 retainCount]);</span><br><span class="line">    [obj2 release];		<span class="comment">//obj2释放，引用计数减1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference count = %lu"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)[obj1 retainCount]);</span><br><span class="line">    [obj1 release];		<span class="comment">//obj1释放，引用计数=1，对象释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">52.035</span> MemoryTest[<span class="number">69135</span>:<span class="number">40583765</span>] Reference count = <span class="number">1</span></span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">52.035</span> MemoryTest[<span class="number">69135</span>:<span class="number">40583765</span>] Reference count = <span class="number">2</span></span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">52.035</span> MemoryTest[<span class="number">69135</span>:<span class="number">40583765</span>] Reference count = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="2-引用计数的存储"><a href="#2-引用计数的存储" class="headerlink" title="2.引用计数的存储"></a>2.引用计数的存储</h4><p>内存管理并不是管理所有内存，<strong>任何继承了<code>NSObject</code>的对象需要进行内存管理</strong>，而对于<strong>基本数据类型</strong>（int、char、short、float、double）、结构体、枚举等不用去关心内存。对象引用计数存储有两种方式：通过一个全局的<strong>散列表</strong>存储；通过<strong>isa</strong>指针存储。</p>
<p>（1）在32位环境下，对象的引用计数都保存在一个全局的散列表中。当对一个对象进行<code>Retain</code>操作时：先获得记录引用计数的散列表；然后对表进行加锁（为了线程安全）；然后读取引用计数加1，并写回散列表；最后解锁。</p>
<p>（2）在64为环境下，如果对象支持使用优化的<code>isa</code>指针，那么对象的引用计数一般会存储在<code>isa</code>指针中。否则的话，还是使用散列表来存储。</p>
<p>下面是在<code>arm64</code>架构的设备下，64位环境中<code>isa</code>指针结构：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   define ISA_MASK        0x00000001fffffff8ULL</span></span><br><span class="line"><span class="meta">#   define ISA_MAGIC_MASK  0x000003fe00000001ULL</span></span><br><span class="line"><span class="meta">#   define ISA_MAGIC_VALUE 0x000001a400000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t shiftcls          : <span class="number">30</span>; </span><br><span class="line">        uintptr_t magic             : <span class="number">9</span>;</span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       define RC_ONE   (1ULL<span class="meta-string">&lt;&lt;45)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#       define RC_HALF  (1ULL&lt;&lt;18)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;;</span></span></span><br></pre></td></tr></table></figure>
<p>针对上面的指针结构，下面是每个bit位的具体作用：    </p>
<table>
<thead>
<tr>
<th><strong>bit位</strong></th>
<th><strong>变量名</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1 bit</td>
<td>indexed</td>
<td>0 表示普通的 <code>isa</code> 指针，1 表示使用优化，即<code>Tagged Pointer</code>存储引用计数</td>
</tr>
<tr>
<td>1 bit</td>
<td>has_assoc</td>
<td>表示该对象是否包含 <code>associated object</code>，如果没有，则析构(释放内存)时会更快    </td>
</tr>
<tr>
<td>1 bit</td>
<td>has_cxx_dtor</td>
<td>表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构（释放内存）时更快</td>
</tr>
<tr>
<td>30 bits</td>
<td>shiftcls</td>
<td>类的指针</td>
</tr>
<tr>
<td>9 bits</td>
<td>magic</td>
<td>固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。</td>
</tr>
<tr>
<td>1 bit</td>
<td>weakly_referenced</td>
<td>表示该对象是否有过 <code>weak</code> 对象，如果没有，则析构（释放内存）时更快</td>
</tr>
<tr>
<td>1 bit</td>
<td>deallocating</td>
<td>表示该对象是否正在析构</td>
</tr>
<tr>
<td>1 bit</td>
<td>has_sidetable_rc</td>
<td>表示该对象的引用计数值是否过大无法存储在 <code>isa</code> 指针</td>
</tr>
<tr>
<td>19 bits</td>
<td>extra_jc</td>
<td>表示引用计数值减一后的结果。例如，如果对象引用计数为4，则extra_jc为3</td>
</tr>
</tbody>
</table>
<p>在64位环境中，即使使用优化的 <code>isa</code> 指针，也不一定存储存储引用计数，因为用19bit保存引用计数不一定够。另外，如果对象的引用计数值过大无法存储在 <code>isa</code> 指针中，即 <code>has_sidetable_rc</code> 值为1时，引用计数会存储在一个叫 <code>SideTable</code> 的类的属性中。</p>
<h4 id="3-引用计数的获取"><a href="#3-引用计数的获取" class="headerlink" title="3.引用计数的获取"></a>3.引用计数的获取</h4><p>（1）在非ARC环境中，我们可以使用 <code>[obj retainCount]</code>方法进行获取。在运行时对象会指向 <code>objc_object</code> 的 <code>rootRetainCount()</code> 方法。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）在ARC环境中。可以使用Core Foundation 库的<code>CFGetRetainCount()</code> 方法：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">NSObject</span> * obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFTypeRef</span> cfObjc = (__bridge <span class="built_in">CFTypeRef</span>)obj;	<span class="comment">//转换为core foundation类型对象</span></span><br><span class="line">    <span class="built_in">NSInteger</span> count = <span class="built_in">CFGetRetainCount</span>(cfObjc);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference count = %ld"</span>,(<span class="keyword">long</span>)count); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用 Runtime 的 _objc_rootRetainCount(id obj) 方法：</p>
<p><strong>注</strong>：需要引入 <code>&lt;objc/runtime.h&gt;</code></p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">extern</span> uintptr_t _objc_rootRetainCount(<span class="keyword">id</span> obj);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> * obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, _objc_rootRetainCount(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_objc_rootRetainCount()</code>方法实现如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!UseGC);</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (uintptr_t)<span class="keyword">this</span>;	<span class="comment">//如果isa为优化指针，即使用Tagged Pointer</span></span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">if</span> (bits.indexed) &#123;</span><br><span class="line">        uintptr_t rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();	<span class="comment">//如果19bit不能存储引用计数，通过调用sidetable_retainCount方法获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由以上程序可以看出，当对象使用 <code>isa</code> 优化指针时，直接返回对想引用计数；64为环境优化的 <code>isa</code> 无法使用时，调用 <code>seidtable_retainCount</code>方法。至于调用 <code>seidtable_retainCount</code>方法的过程，暂不做分析。</p>
<h4 id="4-为什么要使用引用计数"><a href="#4-为什么要使用引用计数" class="headerlink" title="4.为什么要使用引用计数"></a>4.为什么要使用引用计数</h4><p>使用引用计数，主要是为了方便我们管理对象的内存。内存的基本释放原则是：谁申请，谁释放。但是当我们在对象之间传递和共享数据时，会出现以下问题：<br>（1）假如对象A生成了对象T，需要调用对象B的一个方法，将对象T作为参数进行传递，这样对象B就会对T持有一个引用。如果没有引用计数，则按照“谁申请谁释放”的原则进行内存管理，那么对象A就需要在对象B不需要对象T时，对T进行释放。但是对象A不知道对象B会将T持有到什么时候，这样什么时候去释放T就是一个问题，如下图所示：<br><img src="/uploads/Memory-Manage-2-MRC/release.png" alt="releaseImg"></p>
<p>解决方法之一：每次A调用完对象B的方法后，对象B将参数进行拷贝，然后对像A就可以销毁对象T。但是这会带来很多内存申请，影响性能，<strong>不宜采用</strong>。</p>
<p>解决方法之二：对象A生成对象T后，始终不销毁对像T，把管理权交给B，让B来销毁。但是这种方法依赖与A、B两个对象的配合，在对象A中申请，在对象B中释放，管理起来很繁琐，而且当T在多个对象之间传递时（例如对象B将T传递给对象C），很容易出错。所以这种方法也<strong>不宜采用</strong>。</p>
<p>于是就引入了引用计数。对象T在多个对象之间传递过程中，哪些对象对它进行持有，就把它的引用计数加1。当不再持有它时，把它的引用计数减1。当对象T的引用计数为0时，说明此时没有对象在持有它，可以释放，回收其内存。    </p>
<h3 id="二、内存管理关键字"><a href="#二、内存管理关键字" class="headerlink" title="二、内存管理关键字"></a>二、内存管理关键字</h3><p>Objective-C通过引用计数方式来管理内存，调用实例对象的 <code>release</code> 方法后，引用计数减1，当实例对象的引用计数为0时，对象自动调用 <code>dealloc</code> 方法，尽行内存回收。如果需要在对象释放前进行其他操作，我们可以重写对象的 <code>dealloc</code> 方法。</p>
<p>Objective-C内存管理API主要通过以下几个接口进行操作：</p>
<h4 id="1-alloc-allocWithZone-new"><a href="#1-alloc-allocWithZone-new" class="headerlink" title="1.alloc,allocWithZone,new"></a>1.alloc,allocWithZone,new</h4><p>这三个接口的作用是为对象分配内存，引用计数（retainCount）为1，并返回此实例。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSObject</span> *obj2 = [<span class="built_in">NSObject</span> new];    <span class="comment">//自动初始化对象，作用同上。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 <code>allocWithZone:</code> 方法，它的调用基本上和 <code>alloc</code> 方法是一样的。官方文档这样描述“This method exists for historical reasons; memory zones are no longer used by Objective-C”.它的存在是由于历史原因造成的。我们只需要知道<strong><code>alloc</code> 方法的实现调用了 <code>allocWithZone</code>方法</strong>。</p>
</blockquote>
<h4 id="2-release"><a href="#2-release" class="headerlink" title="2.release"></a>2.release</h4><p>使实例对象的引用计数(retainCount)减1，减到0时调用此对象的 <code>dealloc</code> 方法释放内存。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    [obj release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-retain"><a href="#3-retain" class="headerlink" title="3.retain"></a>3.retain</h4><p>使实例对象的引用计数（retainCount）加1。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    [obj <span class="keyword">retain</span>];	<span class="comment">//引用计数 = 2</span></span><br><span class="line">    <span class="built_in">NSObject</span> *anotherObj = [obj <span class="keyword">retain</span>];	<span class="comment">//引用计数 = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-copy-mutableCopy"><a href="#4-copy-mutableCopy" class="headerlink" title="4.copy,mutableCopy"></a>4.copy,mutableCopy</h4><p>复制一个对象实例，得到的对象实例的引用计数为1。这个对象是与上下文无关的，独立的对象。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *arr = [[<span class="built_in">NSArray</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableArr = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *copyArr = [arr <span class="keyword">copy</span>];		<span class="comment">//独立对象，指向地址与arr不同</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableCopyArr = [mutableArr mutableCopy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-autorelease"><a href="#5-autorelease" class="headerlink" title="5.autorelease"></a>5.autorelease</h4><p>在当前上下文的AutoreleasePool栈顶的autoreleasePool实例添加此对象，由于它的引入使Objective-C（非GC管理环境）由全手动内存管理上升到半自动化。即对于<strong>retainCount = 1的对象</strong>，在自动释放池（autoreleasePool）释放时会自动释放，不需要再去手动调用[obj release]。对于autorelease的原理深度剖析，<a href="http://weibo.com/u/1364395395?is_all=1" target="_blank" rel="noopener">@阳神</a>有一篇<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a>讲解的很详细。关于autorelease的使用，后面会讲到。</p>
<h3 id="三、MRC中定义setter方法"><a href="#三、MRC中定义setter方法" class="headerlink" title="三、MRC中定义setter方法"></a>三、MRC中定义setter方法</h3><p>如果一个类的成员变量是另外一个如果一个类中的成员变量是另外一个类，当使用setter方法传递对象时，传递的是指针，指向的还是同一个类。如果另外一个类在传递给setter后，又在另外的地方进行了release，那么再次调用这个类成员变量的getter方法时，就会获取一个野指针，所以为了解决这种问题，需要    这样定义setter方法：<br>1、先判断传递近来的对象跟现有的对象是不是同一个，如果是同一个就没有必须要再进行引用；</p>
<p>2、如果不是同一个对象，就得要先将原有得对象进行release，在将新的对象进行引用并retain这个对象。</p>
<p>3、重写dealloc方法，把对象类型进行一次release。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span>&#123;</span><br><span class="line">    Person *_person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Person *person;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setPerson:(Person *)person;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    Person *newPer = [Person new];</span><br><span class="line">    <span class="keyword">self</span>.person = newPer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setPerson:(Person *)person&#123;</span><br><span class="line">    <span class="keyword">if</span> (_person != person) &#123;  <span class="comment">//判断当前成员变量和传入变量是否相同</span></span><br><span class="line">        [_person release];     <span class="comment">//如果不相同，释放之前的对象</span></span><br><span class="line">        _person = [person <span class="keyword">retain</span>];       <span class="comment">//重新持有新的对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果仅是简单的_person = person;那么当传入的per变量在某一时刻调用[person release]后，_person则会成为一个野指针。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    [<span class="keyword">super</span> dealloc];    <span class="comment">//使父类中一些成员变量能够释放</span></span><br><span class="line">    [_person release];</span><br><span class="line">    <span class="comment">// 另有一种推荐的做法是：[person setPerson:nil];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="四、自动释放池：Autoreleasepool"><a href="#四、自动释放池：Autoreleasepool" class="headerlink" title="四、自动释放池：Autoreleasepool"></a>四、自动释放池：Autoreleasepool</h3><p>AutoreleasePool（自动释放池）使Objective-C成为内存管理半自动化语言。“自动释放池”顾名思义就是一个容器。它的基本使用如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)releaseObj &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj1 = [[[<span class="built_in">NSObject</span> alloc] init] autorelease];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj2 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    [obj2 autorelease];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)[obj2 retainCount]); 	<span class="comment">//retainCount = 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj3 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    [obj3 <span class="keyword">retain</span>];</span><br><span class="line">    [obj3 autorelease];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj4 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    [obj4 <span class="keyword">retain</span>];</span><br><span class="line">    [obj4 autorelease];</span><br><span class="line">    [obj4 autorelease];</span><br><span class="line">    </span><br><span class="line">    [pool release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，包含在 <code>pool</code> 和 <code>[pool release]</code> 之间的对象，凡是调用 <code>autorelease</code> 方法的实例，都被加入了“池子”，即obj1和obj2两个调用性质一样。</p>
<p>AutoreleasePool的基本原理是这样：在声明 <code>pool</code> 和 <code>[pool release]</code>之间生成的实例对象，每有一个实例对象调用 <code>autorelease</code> 方法，都会在<code>pool</code>实例中添1次此实例要回收的记录以做备案。当此<code>pool</code>实例dealloc时，首先会检查之前备案的所有实例，所有记录在案的实例都会依次调用它的<code>release</code>方法。</p>
<p>调用autorelease只是使对象<strong>延迟释放</strong>，并不是立刻释放。如在上述代码中的obj2，调用了<code>autorelease</code>方法，但依然未释放，还可以使用，等到<code>[pool release]</code>才释放。</p>
<p>如果实例对象的retainCount=2,那么调用一次<code>autorelease</code>方法是不能使对象在最终释放的，例如obj3，最终无法释放。如要释放，需要调用和retainCount相同次数<code>autorelease</code>方法，如obj4。</p>
<p>如果AutoleasePool被嵌套调用，起作用的是最里层的pool,例如：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)releaseObj &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool1 = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool2 = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool3 = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [[[<span class="built_in">NSObject</span> alloc] init] autorelease];</span><br><span class="line">    </span><br><span class="line">    [pool3 release];</span><br><span class="line">    [pool2 release];</span><br><span class="line">    [pool1 release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>起作用的是pool3。</p>
<p>对于如何使用AutoreleasePool优化内存，后面的篇章会讲到。</p>
<p>基于MRC(手动引用计数)的内存管理就暂时说到这里，下一篇会主要写基于ARC（自动引用计数）的内存管理。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://book.douban.com/subject/26287173/" target="_blank" rel="noopener">《iOS开发进阶》</a><br>2.<a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/" target="_blank" rel="noopener">Objective-C 引用计数原理</a><br>3.<a href="http://www.cocoachina.com/ios/20120723/4484.html" target="_blank" rel="noopener">Objective-C 内存管理精髓</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/03/30/Memory-Manage-3-ARC/" class="prev">上一篇</a><a href="/2016/03/26/Memory-Manage-1-GettingStarted/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Tue Mar 29 2016 22:27:48 GMT+0800',
    owner: 'boolchow',
    repo: 'boolchow.github.io',
    oauth: {
        client_id: '06247ad6645fcdc4c37c',
        client_secret: 'b3107efca11a366f4da8281d78bf59880f19a253',
    },
})
gitment.render('container')</script><div class="copyright">版权声明：本文为博主原创文章,翻译文章,未经允许不可用于商业用途.<p>© 2015 - 2018 boolchow | powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>