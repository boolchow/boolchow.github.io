<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS内存管理之三：ARC(Automatic Reference Counting) · Hexo</title><meta name="description" content="iOS内存管理之三：ARC(Automatic Reference Counting) - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/3290954642" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/boolchow" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS内存管理之三：ARC(Automatic Reference Counting)</h1><div class="post-info">Mar 30, 2016</div><div class="post-content"><a id="more"></a>
<p>在<a href="http://luoanhao.github.io/2016/03/29/Memory-Manage-2-MRC/" target="_blank" rel="noopener">上一篇</a>文章中，我们主要<br>介绍了基于<strong>MRC</strong>环境下的内存管理。这篇文章主要介绍基于<strong>ARC</strong>环境下的内存管理。从WWDC2011到现在已经有近5年的时间，ACR机制的应用已经十分成熟，如今在Xcode中新建项目，都默认开启ARC。下面我会从ARC的原理到使用进行详细讲解。</p>
<h3 id="一、什么是ARC"><a href="#一、什么是ARC" class="headerlink" title="一、什么是ARC"></a>一、什么是ARC</h3><p>ARC——Automatic Reference Counting，自动引用计数。它<strong>不是运行时特性，不是垃圾回收器（GC）</strong>，而是一种<strong>编译时特性</strong>。    </p>
<blockquote>
<p>Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications.</p>
</blockquote>
<p>与MRC模式相比，在ARC模式下会减少相应的工作量。为什么这样说呢？因为在ARC模式下编写代码，不需要写<code>retain</code>、<code>release</code>、<code>autorelease</code>这三个关键字来对实例对象进行手动管理内存，这会减少很多代码。当开启ARC时，编译器在编译代码时会自动在代码合适的地方插入<code>retain</code>、<code>release</code>和<code>autorelease</code>。也就是说，原来在MRC模式下需要写的类似于<code>[obj release]</code> 这样的代码，在ARC模式下编译器会自动帮我们完成，不需要我们去写，这就是所谓的<strong>自动引用计数</strong>。这样会相应地提高开发效率。</p>
<h3 id="二、ARC工作原理"><a href="#二、ARC工作原理" class="headerlink" title="二、ARC工作原理"></a>二、ARC工作原理</h3><p>ARC模式的基本原理与MRC相同，都是<strong>引用计数原理</strong>，只是书写方式不同。在MRC模式下，如果想要保持一个对象使其不被释放，需要使用<code>retain</code>关键字。在ARC模式下要做的就是用一个指针指向这个对象，只要指针没有被置空，对象就会一直保持在堆上。当将指针指向新值时，原来的对象会被release一次。</p>
<p>ARC可以为开发者节省很多代码，使用ARC以后再也不需要关心什么时候retain，什么时候release，但是这并不意味你可以不思考内存管理，我们需要经常性地问自己这个问题：<strong>谁持有这个对象？</strong></p>
<h4 id="1-“持有”概念"><a href="#1-“持有”概念" class="headerlink" title="1.“持有”概念"></a>1.“持有”概念</h4><p>在ARC中，我们说对象A“持有”对象B，就是说对象A“强引用”对象B。写法如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> * obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSObject</span> * A = obj;		<span class="comment">//A指向obj,此时A对obj有一个引用，强引用</span></span><br></pre></td></tr></table></figure>
<p>引用又分为<strong>强引用</strong>和<strong>弱引用</strong>。被 <code>strong</code> 关键字修饰的对象A，如果指向对象obj,即obj被一个 <code>strong</code> 指针指向，obj被强引用，则obj不会销毁。如果对象没有任何 <code>strong</code> 指针指向，那么就讲销毁。被 <code>weak</code> 关键字修饰的对象B，如果指向对象obj,那么对象obj被一个 <code>weak</code> 指针指向，obj被弱引用，obj是否销毁与其无关。</p>
<p>一个 <code>weak</code> 指针P指向一个对象obj，并没有增加P的引用计数。另外，在ARC模式下，<strong>所有对象指针类型默认为 <code>strong</code> 类型</strong>。</p>
<h4 id="2-理解strong和weak"><a href="#2-理解strong和weak" class="headerlink" title="2.理解strong和weak"></a>2.理解strong和weak</h4><p><code>strong</code> 和 <code>weak</code> 类似于MRC模式下的 <code>retain</code> 和 <code>assign</code> 。请看下图：<br><img src="/uploads/Memory-Manage-3-ARC/Strong.png" alt="strongImg"></p>
<p>在上图中，有两个 <code>strong</code> 类型指针A和B指向O，一个 <code>weak</code> 类型指针C指向O。每有一个 <code>strong</code> 类型指针指向O，在编译时，对象O会进行 <code>[O retain]</code> 一次，此时对象O的引用计数为2。<code>weak</code> 指针对其引用计数没有影响。当对象A或者对象B不再指向O时，对象O的引用计数减1，当没有对象持有时，进行释放。说到底，ARC模式的管理方式还是基于引用计数。</p>
<h3 id="三、ARC修饰符"><a href="#三、ARC修饰符" class="headerlink" title="三、ARC修饰符"></a>三、ARC修饰符</h3><p>在ARC环境下，有4个与内存相关的<strong>变量所有权修饰符</strong>，他们分别是：</p>
<ul>
<li>__strong</li>
<li>__weak</li>
<li>__autoreleasing</li>
<li>__unsafe_unretained</li>
</ul>
<p>这里所说的<strong>变量所有权修饰符</strong>，与属性（property）中的<strong>属性修饰符</strong>不同，他们有如下对应关系：</p>
<ul>
<li><code>assign</code> 对应的所有权类型是 <code>__unsafe_unretained</code></li>
<li><code>copy</code> 对应的所有权类型是 <code>__strong</code></li>
<li><code>retain</code> 对应的所有权类型是 <code>__strong</code></li>
<li><code>strong</code> 对应的所有权类型是 <code>__strong</code></li>
<li><code>unsafe_unretained</code> 对应的所有权类型是 <code>__unsafe_unretained</code></li>
<li><code>weak</code> 对应的所有权类型是 <code>__weak</code></li>
</ul>
<p>关于<strong>属性修饰符</strong>，后面我会写一篇关于 <code>property</code> 的文章进行详细介绍，在此暂时不做介绍。接下来主要介绍一下4个<strong>变量所有权修饰符</strong>。</p>
<h4 id="1-strong"><a href="#1-strong" class="headerlink" title="1.__strong"></a>1.__strong</h4><p><code>__strong</code> 表示引用为强引用。对应定义 property 时用到的 <code>strong</code> 。当对象没有任何一个强引用指向它时，它才会被释放。如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 nil。__strong 修饰符是 id 类型和对象类型默认的所有权修饰符。</p>
<p><strong><code>__strong</code>修饰的变量会自动初始化为 <code>nil</code></strong>。</p>
<h4 id="2-weak"><a href="#2-weak" class="headerlink" title="2.__weak"></a>2.__weak</h4><p><code>__weak</code> 表示弱引用，对应定义 property 时用到的 <code>weak</code>。<code>__weak</code> 最常见的一个作用就是<strong>用来避免强引用循环</strong>。但是需要注意的是，<code>__weak</code> 修饰符只能用于 iOS5 以上的版本，在 iOS4 及更低的版本中使用 <code>__unsafe_unretained</code> 修饰符来代替。关于 <code>__weak</code>,有以下几点需要注意：</p>
<p>（1）弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 nil，这样可以防止野指针。如下图：</p>
<p><img src="/uploads/Memory-Manage-3-ARC/weak.png" alt="weakImg"><br>对于对象N，开始有一个强引用指针A和一个弱引用指针B指向它，之后A指向M，没有强引用指针指向N，N被释放，此时弱引用指针B自动被置为 <code>nil</code>，防止变为野指针。</p>
<p>（2）<code>__weak</code> 主要用来避免循环引用，主要有以下几个应用场景：</p>
<ul>
<li>在使用 <code>delegate</code> 时，我们需要将 <code>delegate</code> 的属性定义为 <code>weak</code>,以避免强引用循环。</li>
</ul>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ClassOneVC:</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassOneViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="keyword">id</span> &lt;myDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span>.delegate func];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">ClassTwoVC:</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassOneViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    ClassOneViewController * classOneVC = [ClassOneViewController new]；</span><br><span class="line">    classOneVC.delegate = <span class="keyword">self</span>	<span class="comment">//delegate为weak类型，不会对self强引用，避免循环引用。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//delegate func</span></span><br><span class="line">- (<span class="keyword">void</span>)func&#123;&#125;;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 Block 中防止强引用循环，后面细讲。</li>
<li>用来修饰指向由 Interface Builder 创建的控件。比如：@property (weak, nonatomic) IBOutlet UIImageView myImgV。<blockquote>
<p>对于在类中使用的UIKit控件，一般为 <code>strong</code> 类型，至于为什么在Interface Builder或者StoryBoard中创建的控件可以用 <code>weak</code> ，有一种解释是在Interface Builder或者StoryBoard中进行了strong，具体什么原理还请大神解答。</p>
</blockquote>
</li>
</ul>
<h4 id="3-autoreleasing"><a href="#3-autoreleasing" class="headerlink" title="3.__autoreleasing"></a>3.__autoreleasing</h4><p>用 <code>__autoreleasing</code> 修饰一个对象，表示这个对象被添加到 <code>autorelease pool</code>中自动释放引用。这和MRC模式下的 <code>autorelease</code> 的用法相同。只不过在MRC模式下，不能够再显示使用 <code>autorelease</code> 方法了，但是 <code>autorelease</code> 的机制还是有效的，即通过使用 <code>autorelease</code> 修饰对象。</p>
<p>下面两行代码意义相同：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString * str = [[[NSString alloc] initWithFormat:@&quot;hello&quot;] autorelease];  //MRC</span><br><span class="line">NSString * __autoreleasing str = [[NSString alloc] initWithFormat:@&quot;hello&quot;];    //ARC</span><br></pre></td></tr></table></figure>
<p>另外，定义property时不能使用这个修饰符，因为任何一个对象的property都不应该是 <code>autorelese</code> 类型。</p>
<p>在ARC模式下，使用（隐式使用）<code>__autoreleasing</code> 的几个场景：</p>
<ul>
<li>方法返回值</li>
<li>访问 <code>__weak</code> 修饰的变量</li>
<li>id类型指针</li>
<li>指针的指针（id *）</li>
<li>某些类方法隐式创建自己的 <code>autorelease pool</code></li>
</ul>
<blockquote>
<p>id 类型类似于(NSObject <em> ）,所以（id </em>）类似于（NSObject ** ）。</p>
</blockquote>
<h5 id="（1）方法返回值"><a href="#（1）方法返回值" class="headerlink" title="（1）方法返回值"></a>（1）方法返回值</h5><p>请看下面代码：    </p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSObject</span> *)myObject &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，<code>obj</code> 的默认所有权修饰符为 <code>__strong</code> 。当return时，使 <code>obj</code>超出其作用域，它强引用持有的对象本应该释放，但是由于该对象作为方法的返回值，所以一般情况下编译器会自动将 <code>obj</code> 注册到 Autorelease Pool中。这样就<strong>延长了</strong>对象的生命周期，使其出了作用域之后，还能够使用。当Autorelease Pool 被销毁的时候，对象的生命周期才会结束。</p>
<p>Autorelease Pool 是与线程一一映射的，这就是说一个 autoreleased 的对象的延迟释放是发生在它所在的 Autorelease Pool 对应的线程上的。。因此，在方法返回值的这个场景中，如果 Autorelease Pool 的 drain 方法没有在接收方和提供方交接的过程中触发，那么 autoreleased 对象是不会被释放的。所以不必担心 “Autorelease Pool 都销毁了，接收方还没接收到对象”这样的问题。</p>
<p>关于Autorelease Pool何时释放，生命周期的问题，实现原理等问题，可以参考这篇文章：<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a>。</p>
<p>#####（2）访问 <code>__weak</code> 修饰变量<br>当访问由 <code>__weak</code> 修饰的变量时，实际访问的是注册到 Autorelease Pool中的对象，例如下面两段代码意义相同：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj0 = [<span class="built_in">NSObject</span> new];</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [obj1 <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时会处理成以下这样：</span></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</span><br><span class="line"><span class="keyword">id</span> __autoreleasing A = obj1;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [A <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>
<p>这样做是为了延长对象的生命周期。因为在 <code>__weak</code> 修饰符只持有对象的弱引用，而在访问对象的过程中，该对象有可能被废弃，如果把被访问的对象注册到 Autorelease Pool 中，就能保证 Autorelease Pool 被销毁前对象是存在的。</p>
<h5 id="3-id类型指针"><a href="#3-id类型指针" class="headerlink" title="(3) id类型指针"></a>(3) id类型指针</h5><p>一个被引用过几百遍的例子，如在使用NSError时：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *__autoreleasing error; </span><br><span class="line"><span class="keyword">if</span> (![data writeToFile:filename options:<span class="built_in">NSDataWritingAtomic</span> error:&amp;error]) </span><br><span class="line">&#123; </span><br><span class="line">　　<span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，如果error定义为 <code>strong</code>类型，即使不用 <code>__autoreleasing</code> 修饰，编译器也会帮你自动添加，保证你传入的是一个 <code>autoreleaing</code> 类型的引用，如下（意义与上段代码相同）：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error; </span><br><span class="line"><span class="built_in">NSError</span> *__autoreleasing tempError = error; <span class="comment">// 编译器自动添加 </span></span><br><span class="line"><span class="keyword">if</span> (![data writeToFile:filename options:<span class="built_in">NSDataWritingAtomic</span> error:&amp;tempError]) </span><br><span class="line">&#123; </span><br><span class="line">　　error = tempError; <span class="comment">// 编译器自动添加添加 </span></span><br><span class="line">　　<span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是为了提高程序效率，我们在定义的error的时候，一般都声明为 <code>autoreleasing</code> 类型。</p>
<h5 id="（4）指针的指针"><a href="#（4）指针的指针" class="headerlink" title="（4）指针的指针"></a>（4）指针的指针</h5><p>在ARC环境下，所有种指针的指针类型（id *）的函数参数如果不加修饰符，编译器会默认将他们认定为 <code>__autoreleasing</code> 类型。例如下面两段代码等价：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myFunc:(<span class="built_in">NSObject</span> **)obj</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myFunc:(<span class="built_in">NSObject</span> * __autoreleasing *)obj</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-类方法隐式创建-Autorelease-Pool"><a href="#5-类方法隐式创建-Autorelease-Pool" class="headerlink" title="(5)类方法隐式创建 Autorelease Pool"></a>(5)类方法隐式创建 Autorelease Pool</h5><p>某些类的方法会隐式地使用自己的Autorelease Pool，例如NSDictionary的[enumerateKeysAndObjectsUsingBlock]方法：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// do stuff  </span></span><br><span class="line">          <span class="keyword">if</span> (there is some error &amp;&amp; error != <span class="literal">nil</span>)</span><br><span class="line">          &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"MyError"</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，会隐式创建一个Autorelease Pool,等价于：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">@autoreleasepool</span>  <span class="comment">// 被隐式创建</span></span><br><span class="line">　　　　　　&#123;</span><br><span class="line">              <span class="keyword">if</span> (there is some error &amp;&amp; error != <span class="literal">nil</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                    *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"MyError"</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *error 在这里已经被dict的做枚举遍历时创建的autorelease pool释放掉了 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够正常的使用*error，我们需要一个strong型的临时引用，在dict的枚举Block中是用这个临时引用，保证引用指向的对象不会在出了dict的枚举Block后被释放，正确的方式如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">　　__block <span class="built_in">NSError</span>* tempError; <span class="comment">// 加__block保证可以在Block内被修改  </span></span><br><span class="line">　　[dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)</span><br><span class="line">　　&#123; </span><br><span class="line">　　　　<span class="keyword">if</span> (there is some error) </span><br><span class="line">　　　　&#123; </span><br><span class="line">　　　　　　*tempError = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"MyError"</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>]; </span><br><span class="line">　　　　&#125;  </span><br><span class="line"></span><br><span class="line">　　&#125;] </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (error != <span class="literal">nil</span>) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　*error = tempError; </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-unsafe-unretained"><a href="#4-unsafe-unretained" class="headerlink" title="4.__unsafe_unretained"></a>4.__unsafe_unretained</h4><p>ARC是在iOS 5引入的，而这个修饰符主要是为了在ARC刚发布时兼容iOS 4以及版本更低的设备，因为这些版本的设备没有weak pointer system，简单的理解这个系统就是我们上面讲weak时提到的，能够在 <code>weak</code> 引用指向对象被释放后，把引用值自动设为 <code>nil</code> 的系统。这个修饰符在定义property时对应的是”unsafe_unretained”，实际可以将它理解为MRC时代的 <code>assign</code> ：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然原原本本地指向原来被释放的对象（所在的内存区域）。所以非常不安全。</p>
<p>现在可以完全忽略掉这个修饰符了，因为iOS 4早已退出历史舞台,目前的APP基本都不会再去兼容iOS4。</p>
<h3 id="四、ARC中的Block"><a href="#四、ARC中的Block" class="headerlink" title="四、ARC中的Block"></a>四、ARC中的Block</h3><p>一般情况下，block捕获的外部变量，可以在block内部使用，但是无法修改，例如下面代码：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * str = <span class="string">@"hello"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^ block)();</span><br><span class="line">    block = ^ (<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str);</span><br><span class="line">        <span class="comment">//str = @"change";</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：static的变量和全局变量不需要加__block就可以在Block中修改</p>
</blockquote>
<p>如果修改 <code>str</code>，编译器会报错。如果想要修改 <code>str</code> ，需要用 <code>__block</code> 修饰符修饰要修改的变量，但也会引入新的问题，请看下面示例：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    MyViewController * __block myController = [[MyViewController alloc] init…];</span><br><span class="line">    </span><br><span class="line">    myController.completionHandler =  ^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">        [myController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，<code>myController</code> 的 <code>completionHandler</code> 调用了 <code>myController</code> 的方法[dismissViewController…]，这时 <code>completionHandler</code> 会对 <code>myController</code> 做 <code>retain</code> 操作。而我们知道，<code>myController</code> 对 <code>completionHandler</code> 也至少有一个retain（一般准确讲是copy），这时就出现了在内存管理中最糟糕的情况：循环引用！</p>
<p>简单点说就是：myController retain了completionHandler，而completionHandler也retain了myController。循环引用导致了myController和completionHandler最终都不能被释放。</p>
<p>针对以上问题，如果循环引用已经产生了，我们可以这样去解决：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __block MyViewController * myController = [[MyViewController alloc] init…];</span><br><span class="line">    </span><br><span class="line">    myController.completionHandler =  ^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">        [myController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">        myController = <span class="literal">nil</span>;  <span class="comment">// 注意这里，将myController置为nil,保证了block结束myController强引用的解除</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免循环引用，大家可能想到这样一个方法：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    MyViewController *myController = [[MyViewController alloc] init…];</span><br><span class="line">    </span><br><span class="line">    MyViewController * __<span class="keyword">weak</span> weakMyController = myController;</span><br><span class="line">    </span><br><span class="line">    myController.completionHandler =  ^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">    	[weakMyViewController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们让block捕获了一个弱引用，即 <code>weakMyController</code>。但是问题又来了：block如果捕获一弱引用，在编译后会将其捕获在自己的函数栈中，当block函数执行完毕，就会释放这个弱引用。那么当myController指向的对象在completionHandler被调用前释放，那么completionHandler就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了。</p>
<p>针对这个问题，有引入了下面的<strong>最佳解决方案</strong>：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    MyViewController *myController = [[MyViewController alloc] init…];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    MyViewController * __<span class="keyword">weak</span> weakMyController = myController;</span><br><span class="line">    </span><br><span class="line">    myController.completionHandler =  ^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">        MyViewController *strongMyController = weakMyController;</span><br><span class="line">        </span><br><span class="line">        　　<span class="keyword">if</span> (strongMyController) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            [strongMyController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// do something...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>block内部定义了一个强引用，这就保证捕获的弱引用 <code>weakMyController</code> 在block函数栈运行结束后不会释放。如果说block存在于堆上，那么 <code>strongMyController</code> 作为block的成员，也会存在于堆上，只有在blokc销毁时，它才会销毁。</p>
<p>关于理解被Block捕获的引用和在Block内定义的引用的区别，及block底层原理，请看唐巧这篇<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">关于block</a>的文章。</p>
<p>最后关于block再说一点。__block在MRC时代有两个作用：    </p>
<ul>
<li>说明变量可改</li>
<li>说明指针指向的对象不做这个隐式的retain操作，用于避免循环引用。</li>
</ul>
<p>在ARC模式下，<strong>__block修饰符只说明变量可修改</strong>。</p>
<h3 id="五、ARC与Toll-Free-Bridging"><a href="#五、ARC与Toll-Free-Bridging" class="headerlink" title="五、ARC与Toll-Free Bridging"></a>五、ARC与Toll-Free Bridging</h3><p>Toll-Free Briding 保证了在程序中，可以方便和谐的使用 Core Foundation 类型的对象和Objective-C 类型的对象。</p>
<h4 id="1-问题的引入"><a href="#1-问题的引入" class="headerlink" title="1.问题的引入"></a>1.问题的引入</h4><p>在 MRC 时代，由于 Objective-C 类型的对象和 Core Foundation 类型的对象都是相同的 release 和 retain 操作规则，所以 Toll-Free Bridging 的使用比较简单，但是自从切换到 ARC 后，Objective-C 类型的对象内存管理规则改变了，不能使用release和retain操作，而 Core Foundation 依然是之前的机制，也就是说，<strong>Core Foundation 不支持 ARC</strong>。</p>
<p>这时候我们就需要解决一个问题：在做 Core Foundation 与 Objective-C 类型转换的时候，我们不仅要做类型转换，还要将其内存管理规则进行转换。</p>
<p>于是苹果在引入 ARC 之后对 Toll-Free Bridging 的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。这些方法和修饰符分别是：</p>
<ul>
<li>__bridge（修饰符）</li>
<li>__bridge_retained（修饰符） or CFBridgingRetain（函数）</li>
<li>__bridge_transfer（修饰符） or CFBridgingRelease（函数）</li>
</ul>
<p>#####（1）__bridge</p>
<p>只是声明类型准换，不做内存管理规则转换。例如：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//NSString 转换为 CFStringRef</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> s1 = (__bridge <span class="built_in">CFStringRef</span>) [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hello"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他对象类型转换</span></span><br><span class="line">    <span class="built_in">CFTypeRef</span> s2 = (__bridge <span class="built_in">CFTypeRef</span>)[<span class="built_in">NSObject</span> new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是做了类型的转化，但管理规则未变，依然要用 Objective-C 类型的 ARC 来管理 s1，你不能用 CFRelease() 去释放 s1。</p>
<p>#####（2）__bridge_retained or CFBridgingRetain<br>表示将指针类型转变的同时，将内存管理的责任由原来的 Objective-C 交给Core Foundation 来处理，也就是，将 ARC 转变为 MRC。例如：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *s1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hello"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFStringRef</span> s2 = (__bridge_retained <span class="built_in">CFStringRef</span>)s1;   <span class="comment">//将内存管理权交给s2</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(s2); <span class="comment">// 注意要在使用结束后加这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时内存管理规则由ARC变为了MRC，我们需要手动的来管理s2的内存，而对于s1，我们即使将其置为nil，也不能释放内存。</p>
<p>上面代码也等价于：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *s1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hello, %@!"</span>, name];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFStringRef</span> s2 = (<span class="built_in">CFStringRef</span>)<span class="built_in">CFBridgingRetain</span>(s1);</span><br><span class="line">    <span class="built_in">CFRelease</span>(s2); <span class="comment">// 注意要在使用结束后加这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-bridge-transfer（修饰符）-or-CFBridgingRelease（函数）"><a href="#3-bridge-transfer（修饰符）-or-CFBridgingRelease（函数）" class="headerlink" title="(3)__bridge_transfer（修饰符） or CFBridgingRelease（函数）"></a>(3)__bridge_transfer（修饰符） or CFBridgingRelease（函数）</h5><p>这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> cfStr = <span class="built_in">CFURLCreateStringByAddingPercentEscapes</span>(. . .);</span><br><span class="line">    <span class="built_in">NSString</span> *str = (__bridge_transfer <span class="built_in">NSString</span> *)cfStr;</span><br><span class="line">    <span class="comment">//or NSString *str = (NSString *)CFBridgingRelease(cfStr);</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将result的管理责任交给了ARC来处理，我们就不需要再显式调用CFRelease()了。</p>
<h3 id="六、循环引用"><a href="#六、循环引用" class="headerlink" title="六、循环引用"></a>六、循环引用</h3><p>在ARC模式下，不用我们去手动管理内存，这方便了很多，也减少了很多工作量。但是ARC模式也有它自己需要注意的问题，那就是<strong>循环引用</strong>。</p>
<h4 id="1-什么是循环引用"><a href="#1-什么是循环引用" class="headerlink" title="1.什么是循环引用"></a>1.什么是循环引用</h4><p>如下图中，对象A和对象B，相互引用对方作为自己的成员变量，只有当对象销毁时，才会将成员变量的计数器减1。但是对象A的销毁依赖于对象B的销毁，对象B的销毁依赖于对象A的销毁。他们互相依赖，谁都不能销毁，这就造成了循环引用。这样即使没有其他强引用指针指向它们，它们也不会销毁。</p>
<p><img src="/uploads/Memory-Manage-3-ARC/retainCircle.png" alt="retainCircleImg"></p>
<p>简单代码示例：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//两个数组，arr1和arr2互相引用</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arr1 = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *arr2 = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    </span><br><span class="line">    [arr1 addObject:arr2];</span><br><span class="line">    [arr2 addObject:arr1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Instruments测试结果：<br><img src="/uploads/Memory-Manage-3-ARC/leaksTest.png" alt="leaksTestImg"></p>
<p>还有一种复杂的循环引用情景，那就是多个对象间依次持有，形成一个环状，这也会造成循环引用问题。例如下图中的情况：<br><img src="/uploads/Memory-Manage-3-ARC/retainCircle2.png" alt="retainCircle2Img"><br>在实际项目开发中，项目的环境比较大，所以一旦产生这种多个对象之间的循环引用，修改起来十分繁琐，所以在实际开发中，应当注意。</p>
<h4 id="2-容易产生循环引用场景"><a href="#2-容易产生循环引用场景" class="headerlink" title="2.容易产生循环引用场景"></a>2.容易产生循环引用场景</h4><p>iOS开发中，有三个场景容易造成循环引用：</p>
<ul>
<li>block 使用</li>
<li>delegate 使用</li>
<li>NSTimer 使用</li>
</ul>
<p>具体如何产生于解除，请看<a href="http://www.cnblogs.com/wengzilin/p/4347974.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<h4 id="3-避免和解除循环引用"><a href="#3-避免和解除循环引用" class="headerlink" title="3.避免和解除循环引用"></a>3.避免和解除循环引用</h4><p>1.如果想要避免产生循环引用，最长见的就是使用弱引用 （<code>weak reference</code>）。弱引用虽然持有对象，但是不增加引用计数，这样就避免了循环引用的产生。</p>
<p>2.如果循环引用已经产生，想要解除循环引用的话，需要开发者手动断开依赖对象。所以如果知道在什么时候断开循环引用回收内存，那就在相应的位置将对象手动置为 <code>nil</code>。</p>
<p>有关ARC模式下内存管理的内容，就写到这里。还请大家勘误。下一篇将介绍几种简单的内存优化方案。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-1" target="_blank" rel="noopener">Beginning ARC in iOS 5 Tutorial Part 1</a></p>
<p>2.<a href="http://www.cnblogs.com/flyFreeZn/p/4264220.html" target="_blank" rel="noopener">iOS开发ARC内存管理技术要点</a></p>
<p>3.<a href="http://www.samirchen.com/ios-arc/" target="_blank" rel="noopener">iOS ARC 内存管理要点</a></p>
<p>4.<a href="https://book.douban.com/subject/26287173/" target="_blank" rel="noopener">iOS开发进阶</a></p>
<div align="center"><br><img src="/uploads/Reward.png" width="248" height="256"><br></div>

</div></article></div></main><footer><div class="paginator"><a href="/2016/04/04/Memory-Manage-4-Memory-Optimization/" class="prev">PREV</a><a href="/2016/03/29/Memory-Manage-2-MRC/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Wed Mar 30 2016 15:13:21 GMT+0800',
    owner: 'boolchow',
    repo: 'boolchow.github.io',
    oauth: {
        client_id: '06247ad6645fcdc4c37c',
        client_secret: 'b3107efca11a366f4da8281d78bf59880f19a253',
    },
})
gitment.render('container')</script><div class="copyright"><p>版权声明 : 本博客为博主原创文章, 翻译文章, 未经允许不可用于商业用途.</p><p>公众号 : @bool周, 不定期更新文章.</p><p>© 2015 - 2018 boolchow | powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-120454091-1",'auto');ga('send','pageview');</script></body></html>